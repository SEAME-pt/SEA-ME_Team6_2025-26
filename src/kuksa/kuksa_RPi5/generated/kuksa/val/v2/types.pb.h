// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kuksa/val/v2/types.proto
// Protobuf C++ Version: 4.25.8

#ifndef GOOGLE_PROTOBUF_INCLUDED_kuksa_2fval_2fv2_2ftypes_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_kuksa_2fval_2fv2_2ftypes_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025008 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_kuksa_2fval_2fv2_2ftypes_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_kuksa_2fval_2fv2_2ftypes_2eproto;
namespace kuksa {
namespace val {
namespace v2 {
class BoolArray;
struct BoolArrayDefaultTypeInternal;
extern BoolArrayDefaultTypeInternal _BoolArray_default_instance_;
class Datapoint;
struct DatapointDefaultTypeInternal;
extern DatapointDefaultTypeInternal _Datapoint_default_instance_;
class DoubleArray;
struct DoubleArrayDefaultTypeInternal;
extern DoubleArrayDefaultTypeInternal _DoubleArray_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class FloatArray;
struct FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class Int32Array;
struct Int32ArrayDefaultTypeInternal;
extern Int32ArrayDefaultTypeInternal _Int32Array_default_instance_;
class Int64Array;
struct Int64ArrayDefaultTypeInternal;
extern Int64ArrayDefaultTypeInternal _Int64Array_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class SampleInterval;
struct SampleIntervalDefaultTypeInternal;
extern SampleIntervalDefaultTypeInternal _SampleInterval_default_instance_;
class SignalID;
struct SignalIDDefaultTypeInternal;
extern SignalIDDefaultTypeInternal _SignalID_default_instance_;
class StringArray;
struct StringArrayDefaultTypeInternal;
extern StringArrayDefaultTypeInternal _StringArray_default_instance_;
class Uint32Array;
struct Uint32ArrayDefaultTypeInternal;
extern Uint32ArrayDefaultTypeInternal _Uint32Array_default_instance_;
class Uint64Array;
struct Uint64ArrayDefaultTypeInternal;
extern Uint64ArrayDefaultTypeInternal _Uint64Array_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace v2
}  // namespace val
}  // namespace kuksa
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace kuksa {
namespace val {
namespace v2 {
enum FilterError : int {
  FILTER_ERROR_CODE_UNSPECIFIED = 0,
  FILTER_ERROR_CODE_UNKNOWN_SINGAL_ID = 1,
  FilterError_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FilterError_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FilterError_IsValid(int value);
extern const uint32_t FilterError_internal_data_[];
constexpr FilterError FilterError_MIN = static_cast<FilterError>(0);
constexpr FilterError FilterError_MAX = static_cast<FilterError>(1);
constexpr int FilterError_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
FilterError_descriptor();
template <typename T>
const std::string& FilterError_Name(T value) {
  static_assert(std::is_same<T, FilterError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FilterError_Name().");
  return FilterError_Name(static_cast<FilterError>(value));
}
template <>
inline const std::string& FilterError_Name(FilterError value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FilterError_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool FilterError_Parse(absl::string_view name, FilterError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FilterError>(
      FilterError_descriptor(), name, value);
}
enum ProviderError : int {
  CODE_UNSPECIFIED = 0,
  CODE_NETWORK_ERROR = 1,
  CODE_OVERLOAD = 2,
  ProviderError_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ProviderError_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ProviderError_IsValid(int value);
extern const uint32_t ProviderError_internal_data_[];
constexpr ProviderError ProviderError_MIN = static_cast<ProviderError>(0);
constexpr ProviderError ProviderError_MAX = static_cast<ProviderError>(2);
constexpr int ProviderError_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ProviderError_descriptor();
template <typename T>
const std::string& ProviderError_Name(T value) {
  static_assert(std::is_same<T, ProviderError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProviderError_Name().");
  return ProviderError_Name(static_cast<ProviderError>(value));
}
template <>
inline const std::string& ProviderError_Name(ProviderError value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ProviderError_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ProviderError_Parse(absl::string_view name, ProviderError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProviderError>(
      ProviderError_descriptor(), name, value);
}
enum ErrorCode : int {
  ERROR_CODE_UNSPECIFIED = 0,
  ERROR_CODE_OK = 1,
  ERROR_CODE_INVALID_ARGUMENT = 2,
  ERROR_CODE_NOT_FOUND = 3,
  ERROR_CODE_PERMISSION_DENIED = 4,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ErrorCode_IsValid(int value);
extern const uint32_t ErrorCode_internal_data_[];
constexpr ErrorCode ErrorCode_MIN = static_cast<ErrorCode>(0);
constexpr ErrorCode ErrorCode_MAX = static_cast<ErrorCode>(4);
constexpr int ErrorCode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ErrorCode_descriptor();
template <typename T>
const std::string& ErrorCode_Name(T value) {
  static_assert(std::is_same<T, ErrorCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorCode_Name().");
  return ErrorCode_Name(static_cast<ErrorCode>(value));
}
template <>
inline const std::string& ErrorCode_Name(ErrorCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ErrorCode_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ErrorCode_Parse(absl::string_view name, ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorCode>(
      ErrorCode_descriptor(), name, value);
}
enum DataType : int {
  DATA_TYPE_UNSPECIFIED = 0,
  DATA_TYPE_STRING = 1,
  DATA_TYPE_BOOLEAN = 2,
  DATA_TYPE_INT8 = 3,
  DATA_TYPE_INT16 = 4,
  DATA_TYPE_INT32 = 5,
  DATA_TYPE_INT64 = 6,
  DATA_TYPE_UINT8 = 7,
  DATA_TYPE_UINT16 = 8,
  DATA_TYPE_UINT32 = 9,
  DATA_TYPE_UINT64 = 10,
  DATA_TYPE_FLOAT = 11,
  DATA_TYPE_DOUBLE = 12,
  DATA_TYPE_TIMESTAMP = 13,
  DATA_TYPE_STRING_ARRAY = 20,
  DATA_TYPE_BOOLEAN_ARRAY = 21,
  DATA_TYPE_INT8_ARRAY = 22,
  DATA_TYPE_INT16_ARRAY = 23,
  DATA_TYPE_INT32_ARRAY = 24,
  DATA_TYPE_INT64_ARRAY = 25,
  DATA_TYPE_UINT8_ARRAY = 26,
  DATA_TYPE_UINT16_ARRAY = 27,
  DATA_TYPE_UINT32_ARRAY = 28,
  DATA_TYPE_UINT64_ARRAY = 29,
  DATA_TYPE_FLOAT_ARRAY = 30,
  DATA_TYPE_DOUBLE_ARRAY = 31,
  DATA_TYPE_TIMESTAMP_ARRAY = 32,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataType_IsValid(int value);
extern const uint32_t DataType_internal_data_[];
constexpr DataType DataType_MIN = static_cast<DataType>(0);
constexpr DataType DataType_MAX = static_cast<DataType>(32);
constexpr int DataType_ARRAYSIZE = 32 + 1;
const ::google::protobuf::EnumDescriptor*
DataType_descriptor();
template <typename T>
const std::string& DataType_Name(T value) {
  static_assert(std::is_same<T, DataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataType_Name().");
  return DataType_Name(static_cast<DataType>(value));
}
template <>
inline const std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DataType_descriptor,
                                                 0, 32>(
      static_cast<int>(value));
}
inline bool DataType_Parse(absl::string_view name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
      DataType_descriptor(), name, value);
}
enum EntryType : int {
  ENTRY_TYPE_UNSPECIFIED = 0,
  ENTRY_TYPE_ATTRIBUTE = 1,
  ENTRY_TYPE_SENSOR = 2,
  ENTRY_TYPE_ACTUATOR = 3,
  EntryType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EntryType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EntryType_IsValid(int value);
extern const uint32_t EntryType_internal_data_[];
constexpr EntryType EntryType_MIN = static_cast<EntryType>(0);
constexpr EntryType EntryType_MAX = static_cast<EntryType>(3);
constexpr int EntryType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
EntryType_descriptor();
template <typename T>
const std::string& EntryType_Name(T value) {
  static_assert(std::is_same<T, EntryType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EntryType_Name().");
  return EntryType_Name(static_cast<EntryType>(value));
}
template <>
inline const std::string& EntryType_Name(EntryType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EntryType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool EntryType_Parse(absl::string_view name, EntryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntryType>(
      EntryType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Uint64Array final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Uint64Array) */ {
 public:
  inline Uint64Array() : Uint64Array(nullptr) {}
  ~Uint64Array() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Uint64Array(::google::protobuf::internal::ConstantInitialized);

  inline Uint64Array(const Uint64Array& from)
      : Uint64Array(nullptr, from) {}
  Uint64Array(Uint64Array&& from) noexcept
    : Uint64Array() {
    *this = ::std::move(from);
  }

  inline Uint64Array& operator=(const Uint64Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint64Array& operator=(Uint64Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint64Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint64Array* internal_default_instance() {
    return reinterpret_cast<const Uint64Array*>(
               &_Uint64Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Uint64Array& a, Uint64Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint64Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint64Array* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint64Array* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint64Array>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Uint64Array& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Uint64Array& from) {
    Uint64Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Uint64Array* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.Uint64Array";
  }
  protected:
  explicit Uint64Array(::google::protobuf::Arena* arena);
  Uint64Array(::google::protobuf::Arena* arena, const Uint64Array& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::uint64_t values(int index) const;
  void set_values(int index, ::uint64_t value);
  void add_values(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& values() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Uint64Array)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::uint64_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Uint32Array final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Uint32Array) */ {
 public:
  inline Uint32Array() : Uint32Array(nullptr) {}
  ~Uint32Array() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Uint32Array(::google::protobuf::internal::ConstantInitialized);

  inline Uint32Array(const Uint32Array& from)
      : Uint32Array(nullptr, from) {}
  Uint32Array(Uint32Array&& from) noexcept
    : Uint32Array() {
    *this = ::std::move(from);
  }

  inline Uint32Array& operator=(const Uint32Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint32Array& operator=(Uint32Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint32Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint32Array* internal_default_instance() {
    return reinterpret_cast<const Uint32Array*>(
               &_Uint32Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Uint32Array& a, Uint32Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint32Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint32Array* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint32Array* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint32Array>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Uint32Array& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Uint32Array& from) {
    Uint32Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Uint32Array* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.Uint32Array";
  }
  protected:
  explicit Uint32Array(::google::protobuf::Arena* arena);
  Uint32Array(::google::protobuf::Arena* arena, const Uint32Array& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::uint32_t values(int index) const;
  void set_values(int index, ::uint32_t value);
  void add_values(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& values() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Uint32Array)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::uint32_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class StringArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.StringArray) */ {
 public:
  inline StringArray() : StringArray(nullptr) {}
  ~StringArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StringArray(::google::protobuf::internal::ConstantInitialized);

  inline StringArray(const StringArray& from)
      : StringArray(nullptr, from) {}
  StringArray(StringArray&& from) noexcept
    : StringArray() {
    *this = ::std::move(from);
  }

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringArray& operator=(StringArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringArray* internal_default_instance() {
    return reinterpret_cast<const StringArray*>(
               &_StringArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StringArray& a, StringArray& b) {
    a.Swap(&b);
  }
  inline void Swap(StringArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StringArray& from) {
    StringArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StringArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.StringArray";
  }
  protected:
  explicit StringArray(::google::protobuf::Arena* arena);
  StringArray(::google::protobuf::Arena* arena, const StringArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, std::size_t size);
  void set_values(int index, absl::string_view value);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, std::size_t size);
  void add_values(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.StringArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class SignalID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.SignalID) */ {
 public:
  inline SignalID() : SignalID(nullptr) {}
  ~SignalID() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SignalID(::google::protobuf::internal::ConstantInitialized);

  inline SignalID(const SignalID& from)
      : SignalID(nullptr, from) {}
  SignalID(SignalID&& from) noexcept
    : SignalID() {
    *this = ::std::move(from);
  }

  inline SignalID& operator=(const SignalID& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalID& operator=(SignalID&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalID& default_instance() {
    return *internal_default_instance();
  }
  enum SignalCase {
    kId = 1,
    kPath = 2,
    SIGNAL_NOT_SET = 0,
  };

  static inline const SignalID* internal_default_instance() {
    return reinterpret_cast<const SignalID*>(
               &_SignalID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SignalID& a, SignalID& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalID* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalID* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalID>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignalID& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SignalID& from) {
    SignalID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SignalID* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.SignalID";
  }
  protected:
  explicit SignalID(::google::protobuf::Arena* arena);
  SignalID(::google::protobuf::Arena* arena, const SignalID& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // string path = 2;
  bool has_path() const;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  void clear_signal();
  SignalCase signal_case() const;
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.SignalID)
 private:
  class _Internal;
  void set_has_id();
  void set_has_path();

  inline bool has_signal() const;
  inline void clear_has_signal();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union SignalUnion {
      constexpr SignalUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t id_;
      ::google::protobuf::internal::ArenaStringPtr path_;
    } signal_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class SampleInterval final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.SampleInterval) */ {
 public:
  inline SampleInterval() : SampleInterval(nullptr) {}
  ~SampleInterval() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SampleInterval(::google::protobuf::internal::ConstantInitialized);

  inline SampleInterval(const SampleInterval& from)
      : SampleInterval(nullptr, from) {}
  SampleInterval(SampleInterval&& from) noexcept
    : SampleInterval() {
    *this = ::std::move(from);
  }

  inline SampleInterval& operator=(const SampleInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline SampleInterval& operator=(SampleInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SampleInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const SampleInterval* internal_default_instance() {
    return reinterpret_cast<const SampleInterval*>(
               &_SampleInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SampleInterval& a, SampleInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(SampleInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SampleInterval* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SampleInterval* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SampleInterval>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SampleInterval& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SampleInterval& from) {
    SampleInterval::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SampleInterval* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.SampleInterval";
  }
  protected:
  explicit SampleInterval(::google::protobuf::Arena* arena);
  SampleInterval(::google::protobuf::Arena* arena, const SampleInterval& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalMsFieldNumber = 1,
  };
  // uint32 interval_ms = 1;
  void clear_interval_ms() ;
  ::uint32_t interval_ms() const;
  void set_interval_ms(::uint32_t value);

  private:
  ::uint32_t _internal_interval_ms() const;
  void _internal_set_interval_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.SampleInterval)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t interval_ms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Int64Array final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Int64Array) */ {
 public:
  inline Int64Array() : Int64Array(nullptr) {}
  ~Int64Array() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Int64Array(::google::protobuf::internal::ConstantInitialized);

  inline Int64Array(const Int64Array& from)
      : Int64Array(nullptr, from) {}
  Int64Array(Int64Array&& from) noexcept
    : Int64Array() {
    *this = ::std::move(from);
  }

  inline Int64Array& operator=(const Int64Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64Array& operator=(Int64Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int64Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int64Array* internal_default_instance() {
    return reinterpret_cast<const Int64Array*>(
               &_Int64Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Int64Array& a, Int64Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Int64Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64Array* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64Array* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int64Array>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int64Array& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Int64Array& from) {
    Int64Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Int64Array* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.Int64Array";
  }
  protected:
  explicit Int64Array(::google::protobuf::Arena* arena);
  Int64Array(::google::protobuf::Arena* arena, const Int64Array& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int64_t values(int index) const;
  void set_values(int index, ::int64_t value);
  void add_values(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& values() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Int64Array)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int64_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Int32Array final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Int32Array) */ {
 public:
  inline Int32Array() : Int32Array(nullptr) {}
  ~Int32Array() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Int32Array(::google::protobuf::internal::ConstantInitialized);

  inline Int32Array(const Int32Array& from)
      : Int32Array(nullptr, from) {}
  Int32Array(Int32Array&& from) noexcept
    : Int32Array() {
    *this = ::std::move(from);
  }

  inline Int32Array& operator=(const Int32Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32Array& operator=(Int32Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int32Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int32Array* internal_default_instance() {
    return reinterpret_cast<const Int32Array*>(
               &_Int32Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Int32Array& a, Int32Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Int32Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int32Array* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int32Array* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int32Array>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int32Array& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Int32Array& from) {
    Int32Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Int32Array* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.Int32Array";
  }
  protected:
  explicit Int32Array(::google::protobuf::Arena* arena);
  Int32Array(::google::protobuf::Arena* arena, const Int32Array& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int32_t values(int index) const;
  void set_values(int index, ::int32_t value);
  void add_values(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& values() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Int32Array)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int32_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class FloatArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.FloatArray) */ {
 public:
  inline FloatArray() : FloatArray(nullptr) {}
  ~FloatArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FloatArray(::google::protobuf::internal::ConstantInitialized);

  inline FloatArray(const FloatArray& from)
      : FloatArray(nullptr, from) {}
  FloatArray(FloatArray&& from) noexcept
    : FloatArray() {
    *this = ::std::move(from);
  }

  inline FloatArray& operator=(const FloatArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatArray& operator=(FloatArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatArray* internal_default_instance() {
    return reinterpret_cast<const FloatArray*>(
               &_FloatArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FloatArray& a, FloatArray& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloatArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FloatArray& from) {
    FloatArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FloatArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.FloatArray";
  }
  protected:
  explicit FloatArray(::google::protobuf::Arena* arena);
  FloatArray(::google::protobuf::Arena* arena, const FloatArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated float values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField<float>& values() const;
  ::google::protobuf::RepeatedField<float>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_values() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.FloatArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Error final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Error(::google::protobuf::internal::ConstantInitialized);

  inline Error(const Error& from)
      : Error(nullptr, from) {}
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Error& from) {
    Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Error* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.Error";
  }
  protected:
  explicit Error(::google::protobuf::Arena* arena);
  Error(::google::protobuf::Arena* arena, const Error& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .kuksa.val.v2.ErrorCode code = 1;
  void clear_code() ;
  ::kuksa::val::v2::ErrorCode code() const;
  void set_code(::kuksa::val::v2::ErrorCode value);

  private:
  ::kuksa::val::v2::ErrorCode _internal_code() const;
  void _internal_set_code(::kuksa::val::v2::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Error)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    int code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class DoubleArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.DoubleArray) */ {
 public:
  inline DoubleArray() : DoubleArray(nullptr) {}
  ~DoubleArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoubleArray(::google::protobuf::internal::ConstantInitialized);

  inline DoubleArray(const DoubleArray& from)
      : DoubleArray(nullptr, from) {}
  DoubleArray(DoubleArray&& from) noexcept
    : DoubleArray() {
    *this = ::std::move(from);
  }

  inline DoubleArray& operator=(const DoubleArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleArray& operator=(DoubleArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleArray* internal_default_instance() {
    return reinterpret_cast<const DoubleArray*>(
               &_DoubleArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DoubleArray& a, DoubleArray& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoubleArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DoubleArray& from) {
    DoubleArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DoubleArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.DoubleArray";
  }
  protected:
  explicit DoubleArray(::google::protobuf::Arena* arena);
  DoubleArray(::google::protobuf::Arena* arena, const DoubleArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField<double>& values() const;
  ::google::protobuf::RepeatedField<double>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_values() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.DoubleArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class BoolArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.BoolArray) */ {
 public:
  inline BoolArray() : BoolArray(nullptr) {}
  ~BoolArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BoolArray(::google::protobuf::internal::ConstantInitialized);

  inline BoolArray(const BoolArray& from)
      : BoolArray(nullptr, from) {}
  BoolArray(BoolArray&& from) noexcept
    : BoolArray() {
    *this = ::std::move(from);
  }

  inline BoolArray& operator=(const BoolArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolArray& operator=(BoolArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolArray* internal_default_instance() {
    return reinterpret_cast<const BoolArray*>(
               &_BoolArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BoolArray& a, BoolArray& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BoolArray& from) {
    BoolArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoolArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.BoolArray";
  }
  protected:
  explicit BoolArray(::google::protobuf::Arena* arena);
  BoolArray(::google::protobuf::Arena* arena, const BoolArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bool values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::google::protobuf::RepeatedField<bool>& values() const;
  ::google::protobuf::RepeatedField<bool>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_values() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.BoolArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<bool> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Value final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Value(::google::protobuf::internal::ConstantInitialized);

  inline Value(const Value& from)
      : Value(nullptr, from) {}
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum TypedValueCase {
    kString = 11,
    kBool = 12,
    kInt32 = 13,
    kInt64 = 14,
    kUint32 = 15,
    kUint64 = 16,
    kFloat = 17,
    kDouble = 18,
    kStringArray = 21,
    kBoolArray = 22,
    kInt32Array = 23,
    kInt64Array = 24,
    kUint32Array = 25,
    kUint64Array = 26,
    kFloatArray = 27,
    kDoubleArray = 28,
    TYPED_VALUE_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Value& from) {
    Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Value* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.Value";
  }
  protected:
  explicit Value(::google::protobuf::Arena* arena);
  Value(::google::protobuf::Arena* arena, const Value& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringFieldNumber = 11,
    kBoolFieldNumber = 12,
    kInt32FieldNumber = 13,
    kInt64FieldNumber = 14,
    kUint32FieldNumber = 15,
    kUint64FieldNumber = 16,
    kFloatFieldNumber = 17,
    kDoubleFieldNumber = 18,
    kStringArrayFieldNumber = 21,
    kBoolArrayFieldNumber = 22,
    kInt32ArrayFieldNumber = 23,
    kInt64ArrayFieldNumber = 24,
    kUint32ArrayFieldNumber = 25,
    kUint64ArrayFieldNumber = 26,
    kFloatArrayFieldNumber = 27,
    kDoubleArrayFieldNumber = 28,
  };
  // string string = 11;
  bool has_string() const;
  void clear_string() ;
  const std::string& string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string(Arg_&& arg, Args_... args);
  std::string* mutable_string();
  PROTOBUF_NODISCARD std::string* release_string();
  void set_allocated_string(std::string* value);

  private:
  const std::string& _internal_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string(
      const std::string& value);
  std::string* _internal_mutable_string();

  public:
  // bool bool = 12;
  bool has_bool_() const;
  void clear_bool_() ;
  bool bool_() const;
  void set_bool_(bool value);

  private:
  bool _internal_bool_() const;
  void _internal_set_bool_(bool value);

  public:
  // sint32 int32 = 13;
  bool has_int32() const;
  void clear_int32() ;
  ::int32_t int32() const;
  void set_int32(::int32_t value);

  private:
  ::int32_t _internal_int32() const;
  void _internal_set_int32(::int32_t value);

  public:
  // sint64 int64 = 14;
  bool has_int64() const;
  void clear_int64() ;
  ::int64_t int64() const;
  void set_int64(::int64_t value);

  private:
  ::int64_t _internal_int64() const;
  void _internal_set_int64(::int64_t value);

  public:
  // uint32 uint32 = 15;
  bool has_uint32() const;
  void clear_uint32() ;
  ::uint32_t uint32() const;
  void set_uint32(::uint32_t value);

  private:
  ::uint32_t _internal_uint32() const;
  void _internal_set_uint32(::uint32_t value);

  public:
  // uint64 uint64 = 16;
  bool has_uint64() const;
  void clear_uint64() ;
  ::uint64_t uint64() const;
  void set_uint64(::uint64_t value);

  private:
  ::uint64_t _internal_uint64() const;
  void _internal_set_uint64(::uint64_t value);

  public:
  // float float = 17;
  bool has_float_() const;
  void clear_float_() ;
  float float_() const;
  void set_float_(float value);

  private:
  float _internal_float_() const;
  void _internal_set_float_(float value);

  public:
  // double double = 18;
  bool has_double_() const;
  void clear_double_() ;
  double double_() const;
  void set_double_(double value);

  private:
  double _internal_double_() const;
  void _internal_set_double_(double value);

  public:
  // .kuksa.val.v2.StringArray string_array = 21;
  bool has_string_array() const;
  private:
  bool _internal_has_string_array() const;

  public:
  void clear_string_array() ;
  const ::kuksa::val::v2::StringArray& string_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::StringArray* release_string_array();
  ::kuksa::val::v2::StringArray* mutable_string_array();
  void set_allocated_string_array(::kuksa::val::v2::StringArray* value);
  void unsafe_arena_set_allocated_string_array(::kuksa::val::v2::StringArray* value);
  ::kuksa::val::v2::StringArray* unsafe_arena_release_string_array();

  private:
  const ::kuksa::val::v2::StringArray& _internal_string_array() const;
  ::kuksa::val::v2::StringArray* _internal_mutable_string_array();

  public:
  // .kuksa.val.v2.BoolArray bool_array = 22;
  bool has_bool_array() const;
  private:
  bool _internal_has_bool_array() const;

  public:
  void clear_bool_array() ;
  const ::kuksa::val::v2::BoolArray& bool_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::BoolArray* release_bool_array();
  ::kuksa::val::v2::BoolArray* mutable_bool_array();
  void set_allocated_bool_array(::kuksa::val::v2::BoolArray* value);
  void unsafe_arena_set_allocated_bool_array(::kuksa::val::v2::BoolArray* value);
  ::kuksa::val::v2::BoolArray* unsafe_arena_release_bool_array();

  private:
  const ::kuksa::val::v2::BoolArray& _internal_bool_array() const;
  ::kuksa::val::v2::BoolArray* _internal_mutable_bool_array();

  public:
  // .kuksa.val.v2.Int32Array int32_array = 23;
  bool has_int32_array() const;
  private:
  bool _internal_has_int32_array() const;

  public:
  void clear_int32_array() ;
  const ::kuksa::val::v2::Int32Array& int32_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Int32Array* release_int32_array();
  ::kuksa::val::v2::Int32Array* mutable_int32_array();
  void set_allocated_int32_array(::kuksa::val::v2::Int32Array* value);
  void unsafe_arena_set_allocated_int32_array(::kuksa::val::v2::Int32Array* value);
  ::kuksa::val::v2::Int32Array* unsafe_arena_release_int32_array();

  private:
  const ::kuksa::val::v2::Int32Array& _internal_int32_array() const;
  ::kuksa::val::v2::Int32Array* _internal_mutable_int32_array();

  public:
  // .kuksa.val.v2.Int64Array int64_array = 24;
  bool has_int64_array() const;
  private:
  bool _internal_has_int64_array() const;

  public:
  void clear_int64_array() ;
  const ::kuksa::val::v2::Int64Array& int64_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Int64Array* release_int64_array();
  ::kuksa::val::v2::Int64Array* mutable_int64_array();
  void set_allocated_int64_array(::kuksa::val::v2::Int64Array* value);
  void unsafe_arena_set_allocated_int64_array(::kuksa::val::v2::Int64Array* value);
  ::kuksa::val::v2::Int64Array* unsafe_arena_release_int64_array();

  private:
  const ::kuksa::val::v2::Int64Array& _internal_int64_array() const;
  ::kuksa::val::v2::Int64Array* _internal_mutable_int64_array();

  public:
  // .kuksa.val.v2.Uint32Array uint32_array = 25;
  bool has_uint32_array() const;
  private:
  bool _internal_has_uint32_array() const;

  public:
  void clear_uint32_array() ;
  const ::kuksa::val::v2::Uint32Array& uint32_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Uint32Array* release_uint32_array();
  ::kuksa::val::v2::Uint32Array* mutable_uint32_array();
  void set_allocated_uint32_array(::kuksa::val::v2::Uint32Array* value);
  void unsafe_arena_set_allocated_uint32_array(::kuksa::val::v2::Uint32Array* value);
  ::kuksa::val::v2::Uint32Array* unsafe_arena_release_uint32_array();

  private:
  const ::kuksa::val::v2::Uint32Array& _internal_uint32_array() const;
  ::kuksa::val::v2::Uint32Array* _internal_mutable_uint32_array();

  public:
  // .kuksa.val.v2.Uint64Array uint64_array = 26;
  bool has_uint64_array() const;
  private:
  bool _internal_has_uint64_array() const;

  public:
  void clear_uint64_array() ;
  const ::kuksa::val::v2::Uint64Array& uint64_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Uint64Array* release_uint64_array();
  ::kuksa::val::v2::Uint64Array* mutable_uint64_array();
  void set_allocated_uint64_array(::kuksa::val::v2::Uint64Array* value);
  void unsafe_arena_set_allocated_uint64_array(::kuksa::val::v2::Uint64Array* value);
  ::kuksa::val::v2::Uint64Array* unsafe_arena_release_uint64_array();

  private:
  const ::kuksa::val::v2::Uint64Array& _internal_uint64_array() const;
  ::kuksa::val::v2::Uint64Array* _internal_mutable_uint64_array();

  public:
  // .kuksa.val.v2.FloatArray float_array = 27;
  bool has_float_array() const;
  private:
  bool _internal_has_float_array() const;

  public:
  void clear_float_array() ;
  const ::kuksa::val::v2::FloatArray& float_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::FloatArray* release_float_array();
  ::kuksa::val::v2::FloatArray* mutable_float_array();
  void set_allocated_float_array(::kuksa::val::v2::FloatArray* value);
  void unsafe_arena_set_allocated_float_array(::kuksa::val::v2::FloatArray* value);
  ::kuksa::val::v2::FloatArray* unsafe_arena_release_float_array();

  private:
  const ::kuksa::val::v2::FloatArray& _internal_float_array() const;
  ::kuksa::val::v2::FloatArray* _internal_mutable_float_array();

  public:
  // .kuksa.val.v2.DoubleArray double_array = 28;
  bool has_double_array() const;
  private:
  bool _internal_has_double_array() const;

  public:
  void clear_double_array() ;
  const ::kuksa::val::v2::DoubleArray& double_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::DoubleArray* release_double_array();
  ::kuksa::val::v2::DoubleArray* mutable_double_array();
  void set_allocated_double_array(::kuksa::val::v2::DoubleArray* value);
  void unsafe_arena_set_allocated_double_array(::kuksa::val::v2::DoubleArray* value);
  ::kuksa::val::v2::DoubleArray* unsafe_arena_release_double_array();

  private:
  const ::kuksa::val::v2::DoubleArray& _internal_double_array() const;
  ::kuksa::val::v2::DoubleArray* _internal_mutable_double_array();

  public:
  void clear_typed_value();
  TypedValueCase typed_value_case() const;
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Value)
 private:
  class _Internal;
  void set_has_string();
  void set_has_bool_();
  void set_has_int32();
  void set_has_int64();
  void set_has_uint32();
  void set_has_uint64();
  void set_has_float_();
  void set_has_double_();
  void set_has_string_array();
  void set_has_bool_array();
  void set_has_int32_array();
  void set_has_int64_array();
  void set_has_uint32_array();
  void set_has_uint64_array();
  void set_has_float_array();
  void set_has_double_array();

  inline bool has_typed_value() const;
  inline void clear_has_typed_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 16, 8,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypedValueUnion {
      constexpr TypedValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr string_;
      bool bool__;
      ::int32_t int32_;
      ::int64_t int64_;
      ::uint32_t uint32_;
      ::uint64_t uint64_;
      float float__;
      double double__;
      ::kuksa::val::v2::StringArray* string_array_;
      ::kuksa::val::v2::BoolArray* bool_array_;
      ::kuksa::val::v2::Int32Array* int32_array_;
      ::kuksa::val::v2::Int64Array* int64_array_;
      ::kuksa::val::v2::Uint32Array* uint32_array_;
      ::kuksa::val::v2::Uint64Array* uint64_array_;
      ::kuksa::val::v2::FloatArray* float_array_;
      ::kuksa::val::v2::DoubleArray* double_array_;
    } typed_value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Filter final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Filter(::google::protobuf::internal::ConstantInitialized);

  inline Filter(const Filter& from)
      : Filter(nullptr, from) {}
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Filter& from) {
    Filter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Filter* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.Filter";
  }
  protected:
  explicit Filter(::google::protobuf::Arena* arena);
  Filter(::google::protobuf::Arena* arena, const Filter& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinSampleIntervalFieldNumber = 2,
    kDurationMsFieldNumber = 1,
  };
  // .kuksa.val.v2.SampleInterval min_sample_interval = 2;
  bool has_min_sample_interval() const;
  void clear_min_sample_interval() ;
  const ::kuksa::val::v2::SampleInterval& min_sample_interval() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::SampleInterval* release_min_sample_interval();
  ::kuksa::val::v2::SampleInterval* mutable_min_sample_interval();
  void set_allocated_min_sample_interval(::kuksa::val::v2::SampleInterval* value);
  void unsafe_arena_set_allocated_min_sample_interval(::kuksa::val::v2::SampleInterval* value);
  ::kuksa::val::v2::SampleInterval* unsafe_arena_release_min_sample_interval();

  private:
  const ::kuksa::val::v2::SampleInterval& _internal_min_sample_interval() const;
  ::kuksa::val::v2::SampleInterval* _internal_mutable_min_sample_interval();

  public:
  // uint32 duration_ms = 1;
  void clear_duration_ms() ;
  ::uint32_t duration_ms() const;
  void set_duration_ms(::uint32_t value);

  private:
  ::uint32_t _internal_duration_ms() const;
  void _internal_set_duration_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Filter)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::kuksa::val::v2::SampleInterval* min_sample_interval_;
    ::uint32_t duration_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Metadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Metadata(::google::protobuf::internal::ConstantInitialized);

  inline Metadata(const Metadata& from)
      : Metadata(nullptr, from) {}
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Metadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Metadata& from) {
    Metadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Metadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.Metadata";
  }
  protected:
  explicit Metadata(::google::protobuf::Arena* arena);
  Metadata(::google::protobuf::Arena* arena, const Metadata& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 9,
    kDescriptionFieldNumber = 13,
    kCommentFieldNumber = 14,
    kDeprecationFieldNumber = 15,
    kUnitFieldNumber = 16,
    kAllowedValuesFieldNumber = 17,
    kMinFieldNumber = 18,
    kMaxFieldNumber = 19,
    kMinSampleIntervalFieldNumber = 20,
    kIdFieldNumber = 10,
    kDataTypeFieldNumber = 11,
    kEntryTypeFieldNumber = 12,
  };
  // string path = 9;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // string description = 13;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string comment = 14;
  void clear_comment() ;
  const std::string& comment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comment(Arg_&& arg, Args_... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* value);

  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(
      const std::string& value);
  std::string* _internal_mutable_comment();

  public:
  // string deprecation = 15;
  void clear_deprecation() ;
  const std::string& deprecation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deprecation(Arg_&& arg, Args_... args);
  std::string* mutable_deprecation();
  PROTOBUF_NODISCARD std::string* release_deprecation();
  void set_allocated_deprecation(std::string* value);

  private:
  const std::string& _internal_deprecation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecation(
      const std::string& value);
  std::string* _internal_mutable_deprecation();

  public:
  // string unit = 16;
  void clear_unit() ;
  const std::string& unit() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unit(Arg_&& arg, Args_... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* value);

  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(
      const std::string& value);
  std::string* _internal_mutable_unit();

  public:
  // .kuksa.val.v2.Value allowed_values = 17;
  bool has_allowed_values() const;
  void clear_allowed_values() ;
  const ::kuksa::val::v2::Value& allowed_values() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Value* release_allowed_values();
  ::kuksa::val::v2::Value* mutable_allowed_values();
  void set_allocated_allowed_values(::kuksa::val::v2::Value* value);
  void unsafe_arena_set_allocated_allowed_values(::kuksa::val::v2::Value* value);
  ::kuksa::val::v2::Value* unsafe_arena_release_allowed_values();

  private:
  const ::kuksa::val::v2::Value& _internal_allowed_values() const;
  ::kuksa::val::v2::Value* _internal_mutable_allowed_values();

  public:
  // .kuksa.val.v2.Value min = 18;
  bool has_min() const;
  void clear_min() ;
  const ::kuksa::val::v2::Value& min() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Value* release_min();
  ::kuksa::val::v2::Value* mutable_min();
  void set_allocated_min(::kuksa::val::v2::Value* value);
  void unsafe_arena_set_allocated_min(::kuksa::val::v2::Value* value);
  ::kuksa::val::v2::Value* unsafe_arena_release_min();

  private:
  const ::kuksa::val::v2::Value& _internal_min() const;
  ::kuksa::val::v2::Value* _internal_mutable_min();

  public:
  // .kuksa.val.v2.Value max = 19;
  bool has_max() const;
  void clear_max() ;
  const ::kuksa::val::v2::Value& max() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Value* release_max();
  ::kuksa::val::v2::Value* mutable_max();
  void set_allocated_max(::kuksa::val::v2::Value* value);
  void unsafe_arena_set_allocated_max(::kuksa::val::v2::Value* value);
  ::kuksa::val::v2::Value* unsafe_arena_release_max();

  private:
  const ::kuksa::val::v2::Value& _internal_max() const;
  ::kuksa::val::v2::Value* _internal_mutable_max();

  public:
  // .kuksa.val.v2.SampleInterval min_sample_interval = 20;
  bool has_min_sample_interval() const;
  void clear_min_sample_interval() ;
  const ::kuksa::val::v2::SampleInterval& min_sample_interval() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::SampleInterval* release_min_sample_interval();
  ::kuksa::val::v2::SampleInterval* mutable_min_sample_interval();
  void set_allocated_min_sample_interval(::kuksa::val::v2::SampleInterval* value);
  void unsafe_arena_set_allocated_min_sample_interval(::kuksa::val::v2::SampleInterval* value);
  ::kuksa::val::v2::SampleInterval* unsafe_arena_release_min_sample_interval();

  private:
  const ::kuksa::val::v2::SampleInterval& _internal_min_sample_interval() const;
  ::kuksa::val::v2::SampleInterval* _internal_mutable_min_sample_interval();

  public:
  // int32 id = 10;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .kuksa.val.v2.DataType data_type = 11;
  void clear_data_type() ;
  ::kuksa::val::v2::DataType data_type() const;
  void set_data_type(::kuksa::val::v2::DataType value);

  private:
  ::kuksa::val::v2::DataType _internal_data_type() const;
  void _internal_set_data_type(::kuksa::val::v2::DataType value);

  public:
  // .kuksa.val.v2.EntryType entry_type = 12;
  void clear_entry_type() ;
  ::kuksa::val::v2::EntryType entry_type() const;
  void set_entry_type(::kuksa::val::v2::EntryType value);

  private:
  ::kuksa::val::v2::EntryType _internal_entry_type() const;
  void _internal_set_entry_type(::kuksa::val::v2::EntryType value);

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Metadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 4,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr comment_;
    ::google::protobuf::internal::ArenaStringPtr deprecation_;
    ::google::protobuf::internal::ArenaStringPtr unit_;
    ::kuksa::val::v2::Value* allowed_values_;
    ::kuksa::val::v2::Value* min_;
    ::kuksa::val::v2::Value* max_;
    ::kuksa::val::v2::SampleInterval* min_sample_interval_;
    ::int32_t id_;
    int data_type_;
    int entry_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Datapoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Datapoint) */ {
 public:
  inline Datapoint() : Datapoint(nullptr) {}
  ~Datapoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Datapoint(::google::protobuf::internal::ConstantInitialized);

  inline Datapoint(const Datapoint& from)
      : Datapoint(nullptr, from) {}
  Datapoint(Datapoint&& from) noexcept
    : Datapoint() {
    *this = ::std::move(from);
  }

  inline Datapoint& operator=(const Datapoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datapoint& operator=(Datapoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Datapoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Datapoint* internal_default_instance() {
    return reinterpret_cast<const Datapoint*>(
               &_Datapoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Datapoint& a, Datapoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Datapoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Datapoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Datapoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Datapoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Datapoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Datapoint& from) {
    Datapoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Datapoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "kuksa.val.v2.Datapoint";
  }
  protected:
  explicit Datapoint(::google::protobuf::Arena* arena);
  Datapoint(::google::protobuf::Arena* arena, const Datapoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .kuksa.val.v2.Value value = 2;
  bool has_value() const;
  void clear_value() ;
  const ::kuksa::val::v2::Value& value() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Value* release_value();
  ::kuksa::val::v2::Value* mutable_value();
  void set_allocated_value(::kuksa::val::v2::Value* value);
  void unsafe_arena_set_allocated_value(::kuksa::val::v2::Value* value);
  ::kuksa::val::v2::Value* unsafe_arena_release_value();

  private:
  const ::kuksa::val::v2::Value& _internal_value() const;
  ::kuksa::val::v2::Value* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Datapoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* timestamp_;
    ::kuksa::val::v2::Value* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Datapoint

// .google.protobuf.Timestamp timestamp = 1;
inline bool Datapoint::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Datapoint::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Datapoint::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Datapoint.timestamp)
  return _internal_timestamp();
}
inline void Datapoint::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Datapoint.timestamp)
}
inline ::google::protobuf::Timestamp* Datapoint::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Datapoint::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Datapoint.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Datapoint::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* Datapoint::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Datapoint.timestamp)
  return _msg;
}
inline void Datapoint::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Datapoint.timestamp)
}

// .kuksa.val.v2.Value value = 2;
inline bool Datapoint::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void Datapoint::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kuksa::val::v2::Value& Datapoint::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kuksa::val::v2::Value* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Value&>(::kuksa::val::v2::_Value_default_instance_);
}
inline const ::kuksa::val::v2::Value& Datapoint::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Datapoint.value)
  return _internal_value();
}
inline void Datapoint::unsafe_arena_set_allocated_value(::kuksa::val::v2::Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::kuksa::val::v2::Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Datapoint.value)
}
inline ::kuksa::val::v2::Value* Datapoint::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kuksa::val::v2::Value* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kuksa::val::v2::Value* Datapoint::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Datapoint.value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kuksa::val::v2::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Value* Datapoint::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Value>(GetArena());
    _impl_.value_ = reinterpret_cast<::kuksa::val::v2::Value*>(p);
  }
  return _impl_.value_;
}
inline ::kuksa::val::v2::Value* Datapoint::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::Value* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Datapoint.value)
  return _msg;
}
inline void Datapoint::set_allocated_value(::kuksa::val::v2::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::kuksa::val::v2::Value*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::kuksa::val::v2::Value*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.value_ = reinterpret_cast<::kuksa::val::v2::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Datapoint.value)
}

// -------------------------------------------------------------------

// Value

// string string = 11;
inline bool Value::has_string() const {
  return typed_value_case() == kString;
}
inline void Value::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline void Value::clear_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kString) {
    _impl_.typed_value_.string_.Destroy();
    clear_has_typed_value();
  }
}
inline const std::string& Value::string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.string)
  return _internal_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Value::set_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() != kString) {
    clear_typed_value();

    set_has_string();
    _impl_.typed_value_.string_.InitDefault();
  }
  _impl_.typed_value_.string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.string)
}
inline std::string* Value::mutable_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.string)
  return _s;
}
inline const std::string& Value::_internal_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (typed_value_case() != kString) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.typed_value_.string_.Get();
}
inline void Value::_internal_set_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() != kString) {
    clear_typed_value();

    set_has_string();
    _impl_.typed_value_.string_.InitDefault();
  }
  _impl_.typed_value_.string_.Set(value, GetArena());
}
inline std::string* Value::_internal_mutable_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() != kString) {
    clear_typed_value();

    set_has_string();
    _impl_.typed_value_.string_.InitDefault();
  }
  return _impl_.typed_value_.string_.Mutable( GetArena());
}
inline std::string* Value::release_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.string)
  if (typed_value_case() != kString) {
    return nullptr;
  }
  clear_has_typed_value();
  return _impl_.typed_value_.string_.Release();
}
inline void Value::set_allocated_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_typed_value()) {
    clear_typed_value();
  }
  if (value != nullptr) {
    set_has_string();
    _impl_.typed_value_.string_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Value.string)
}

// bool bool = 12;
inline bool Value::has_bool_() const {
  return typed_value_case() == kBool;
}
inline void Value::set_has_bool_() {
  _impl_._oneof_case_[0] = kBool;
}
inline void Value::clear_bool_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kBool) {
    _impl_.typed_value_.bool__ = false;
    clear_has_typed_value();
  }
}
inline bool Value::bool_() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.bool)
  return _internal_bool_();
}
inline void Value::set_bool_(bool value) {
  _internal_set_bool_(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.bool)
}
inline bool Value::_internal_bool_() const {
  if (typed_value_case() == kBool) {
    return _impl_.typed_value_.bool__;
  }
  return false;
}
inline void Value::_internal_set_bool_(bool value) {
  if (typed_value_case() != kBool) {
    clear_typed_value();
    set_has_bool_();
  }
  _impl_.typed_value_.bool__ = value;
}

// sint32 int32 = 13;
inline bool Value::has_int32() const {
  return typed_value_case() == kInt32;
}
inline void Value::set_has_int32() {
  _impl_._oneof_case_[0] = kInt32;
}
inline void Value::clear_int32() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kInt32) {
    _impl_.typed_value_.int32_ = 0;
    clear_has_typed_value();
  }
}
inline ::int32_t Value::int32() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.int32)
  return _internal_int32();
}
inline void Value::set_int32(::int32_t value) {
  _internal_set_int32(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.int32)
}
inline ::int32_t Value::_internal_int32() const {
  if (typed_value_case() == kInt32) {
    return _impl_.typed_value_.int32_;
  }
  return 0;
}
inline void Value::_internal_set_int32(::int32_t value) {
  if (typed_value_case() != kInt32) {
    clear_typed_value();
    set_has_int32();
  }
  _impl_.typed_value_.int32_ = value;
}

// sint64 int64 = 14;
inline bool Value::has_int64() const {
  return typed_value_case() == kInt64;
}
inline void Value::set_has_int64() {
  _impl_._oneof_case_[0] = kInt64;
}
inline void Value::clear_int64() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kInt64) {
    _impl_.typed_value_.int64_ = ::int64_t{0};
    clear_has_typed_value();
  }
}
inline ::int64_t Value::int64() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.int64)
  return _internal_int64();
}
inline void Value::set_int64(::int64_t value) {
  _internal_set_int64(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.int64)
}
inline ::int64_t Value::_internal_int64() const {
  if (typed_value_case() == kInt64) {
    return _impl_.typed_value_.int64_;
  }
  return ::int64_t{0};
}
inline void Value::_internal_set_int64(::int64_t value) {
  if (typed_value_case() != kInt64) {
    clear_typed_value();
    set_has_int64();
  }
  _impl_.typed_value_.int64_ = value;
}

// uint32 uint32 = 15;
inline bool Value::has_uint32() const {
  return typed_value_case() == kUint32;
}
inline void Value::set_has_uint32() {
  _impl_._oneof_case_[0] = kUint32;
}
inline void Value::clear_uint32() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kUint32) {
    _impl_.typed_value_.uint32_ = 0u;
    clear_has_typed_value();
  }
}
inline ::uint32_t Value::uint32() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.uint32)
  return _internal_uint32();
}
inline void Value::set_uint32(::uint32_t value) {
  _internal_set_uint32(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.uint32)
}
inline ::uint32_t Value::_internal_uint32() const {
  if (typed_value_case() == kUint32) {
    return _impl_.typed_value_.uint32_;
  }
  return 0u;
}
inline void Value::_internal_set_uint32(::uint32_t value) {
  if (typed_value_case() != kUint32) {
    clear_typed_value();
    set_has_uint32();
  }
  _impl_.typed_value_.uint32_ = value;
}

// uint64 uint64 = 16;
inline bool Value::has_uint64() const {
  return typed_value_case() == kUint64;
}
inline void Value::set_has_uint64() {
  _impl_._oneof_case_[0] = kUint64;
}
inline void Value::clear_uint64() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kUint64) {
    _impl_.typed_value_.uint64_ = ::uint64_t{0u};
    clear_has_typed_value();
  }
}
inline ::uint64_t Value::uint64() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.uint64)
  return _internal_uint64();
}
inline void Value::set_uint64(::uint64_t value) {
  _internal_set_uint64(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.uint64)
}
inline ::uint64_t Value::_internal_uint64() const {
  if (typed_value_case() == kUint64) {
    return _impl_.typed_value_.uint64_;
  }
  return ::uint64_t{0u};
}
inline void Value::_internal_set_uint64(::uint64_t value) {
  if (typed_value_case() != kUint64) {
    clear_typed_value();
    set_has_uint64();
  }
  _impl_.typed_value_.uint64_ = value;
}

// float float = 17;
inline bool Value::has_float_() const {
  return typed_value_case() == kFloat;
}
inline void Value::set_has_float_() {
  _impl_._oneof_case_[0] = kFloat;
}
inline void Value::clear_float_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kFloat) {
    _impl_.typed_value_.float__ = 0;
    clear_has_typed_value();
  }
}
inline float Value::float_() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.float)
  return _internal_float_();
}
inline void Value::set_float_(float value) {
  _internal_set_float_(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.float)
}
inline float Value::_internal_float_() const {
  if (typed_value_case() == kFloat) {
    return _impl_.typed_value_.float__;
  }
  return 0;
}
inline void Value::_internal_set_float_(float value) {
  if (typed_value_case() != kFloat) {
    clear_typed_value();
    set_has_float_();
  }
  _impl_.typed_value_.float__ = value;
}

// double double = 18;
inline bool Value::has_double_() const {
  return typed_value_case() == kDouble;
}
inline void Value::set_has_double_() {
  _impl_._oneof_case_[0] = kDouble;
}
inline void Value::clear_double_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kDouble) {
    _impl_.typed_value_.double__ = 0;
    clear_has_typed_value();
  }
}
inline double Value::double_() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.double)
  return _internal_double_();
}
inline void Value::set_double_(double value) {
  _internal_set_double_(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.double)
}
inline double Value::_internal_double_() const {
  if (typed_value_case() == kDouble) {
    return _impl_.typed_value_.double__;
  }
  return 0;
}
inline void Value::_internal_set_double_(double value) {
  if (typed_value_case() != kDouble) {
    clear_typed_value();
    set_has_double_();
  }
  _impl_.typed_value_.double__ = value;
}

// .kuksa.val.v2.StringArray string_array = 21;
inline bool Value::has_string_array() const {
  return typed_value_case() == kStringArray;
}
inline bool Value::_internal_has_string_array() const {
  return typed_value_case() == kStringArray;
}
inline void Value::set_has_string_array() {
  _impl_._oneof_case_[0] = kStringArray;
}
inline void Value::clear_string_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kStringArray) {
    if (GetArena() == nullptr) {
      delete _impl_.typed_value_.string_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::StringArray* Value::release_string_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.string_array)
  if (typed_value_case() == kStringArray) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.string_array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.string_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::StringArray& Value::_internal_string_array() const {
  return typed_value_case() == kStringArray ? *_impl_.typed_value_.string_array_ : reinterpret_cast<::kuksa::val::v2::StringArray&>(::kuksa::val::v2::_StringArray_default_instance_);
}
inline const ::kuksa::val::v2::StringArray& Value::string_array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.string_array)
  return _internal_string_array();
}
inline ::kuksa::val::v2::StringArray* Value::unsafe_arena_release_string_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.string_array)
  if (typed_value_case() == kStringArray) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.string_array_;
    _impl_.typed_value_.string_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_string_array(::kuksa::val::v2::StringArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_typed_value();
  if (value) {
    set_has_string_array();
    _impl_.typed_value_.string_array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.string_array)
}
inline ::kuksa::val::v2::StringArray* Value::_internal_mutable_string_array() {
  if (typed_value_case() != kStringArray) {
    clear_typed_value();
    set_has_string_array();
    _impl_.typed_value_.string_array_ = CreateMaybeMessage<::kuksa::val::v2::StringArray>(GetArena());
  }
  return _impl_.typed_value_.string_array_;
}
inline ::kuksa::val::v2::StringArray* Value::mutable_string_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::StringArray* _msg = _internal_mutable_string_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.string_array)
  return _msg;
}

// .kuksa.val.v2.BoolArray bool_array = 22;
inline bool Value::has_bool_array() const {
  return typed_value_case() == kBoolArray;
}
inline bool Value::_internal_has_bool_array() const {
  return typed_value_case() == kBoolArray;
}
inline void Value::set_has_bool_array() {
  _impl_._oneof_case_[0] = kBoolArray;
}
inline void Value::clear_bool_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kBoolArray) {
    if (GetArena() == nullptr) {
      delete _impl_.typed_value_.bool_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::BoolArray* Value::release_bool_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.bool_array)
  if (typed_value_case() == kBoolArray) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.bool_array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.bool_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::BoolArray& Value::_internal_bool_array() const {
  return typed_value_case() == kBoolArray ? *_impl_.typed_value_.bool_array_ : reinterpret_cast<::kuksa::val::v2::BoolArray&>(::kuksa::val::v2::_BoolArray_default_instance_);
}
inline const ::kuksa::val::v2::BoolArray& Value::bool_array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.bool_array)
  return _internal_bool_array();
}
inline ::kuksa::val::v2::BoolArray* Value::unsafe_arena_release_bool_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.bool_array)
  if (typed_value_case() == kBoolArray) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.bool_array_;
    _impl_.typed_value_.bool_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_bool_array(::kuksa::val::v2::BoolArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_typed_value();
  if (value) {
    set_has_bool_array();
    _impl_.typed_value_.bool_array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.bool_array)
}
inline ::kuksa::val::v2::BoolArray* Value::_internal_mutable_bool_array() {
  if (typed_value_case() != kBoolArray) {
    clear_typed_value();
    set_has_bool_array();
    _impl_.typed_value_.bool_array_ = CreateMaybeMessage<::kuksa::val::v2::BoolArray>(GetArena());
  }
  return _impl_.typed_value_.bool_array_;
}
inline ::kuksa::val::v2::BoolArray* Value::mutable_bool_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::BoolArray* _msg = _internal_mutable_bool_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.bool_array)
  return _msg;
}

// .kuksa.val.v2.Int32Array int32_array = 23;
inline bool Value::has_int32_array() const {
  return typed_value_case() == kInt32Array;
}
inline bool Value::_internal_has_int32_array() const {
  return typed_value_case() == kInt32Array;
}
inline void Value::set_has_int32_array() {
  _impl_._oneof_case_[0] = kInt32Array;
}
inline void Value::clear_int32_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kInt32Array) {
    if (GetArena() == nullptr) {
      delete _impl_.typed_value_.int32_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::Int32Array* Value::release_int32_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.int32_array)
  if (typed_value_case() == kInt32Array) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.int32_array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.int32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::Int32Array& Value::_internal_int32_array() const {
  return typed_value_case() == kInt32Array ? *_impl_.typed_value_.int32_array_ : reinterpret_cast<::kuksa::val::v2::Int32Array&>(::kuksa::val::v2::_Int32Array_default_instance_);
}
inline const ::kuksa::val::v2::Int32Array& Value::int32_array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.int32_array)
  return _internal_int32_array();
}
inline ::kuksa::val::v2::Int32Array* Value::unsafe_arena_release_int32_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.int32_array)
  if (typed_value_case() == kInt32Array) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.int32_array_;
    _impl_.typed_value_.int32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_int32_array(::kuksa::val::v2::Int32Array* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_typed_value();
  if (value) {
    set_has_int32_array();
    _impl_.typed_value_.int32_array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.int32_array)
}
inline ::kuksa::val::v2::Int32Array* Value::_internal_mutable_int32_array() {
  if (typed_value_case() != kInt32Array) {
    clear_typed_value();
    set_has_int32_array();
    _impl_.typed_value_.int32_array_ = CreateMaybeMessage<::kuksa::val::v2::Int32Array>(GetArena());
  }
  return _impl_.typed_value_.int32_array_;
}
inline ::kuksa::val::v2::Int32Array* Value::mutable_int32_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::Int32Array* _msg = _internal_mutable_int32_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.int32_array)
  return _msg;
}

// .kuksa.val.v2.Int64Array int64_array = 24;
inline bool Value::has_int64_array() const {
  return typed_value_case() == kInt64Array;
}
inline bool Value::_internal_has_int64_array() const {
  return typed_value_case() == kInt64Array;
}
inline void Value::set_has_int64_array() {
  _impl_._oneof_case_[0] = kInt64Array;
}
inline void Value::clear_int64_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kInt64Array) {
    if (GetArena() == nullptr) {
      delete _impl_.typed_value_.int64_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::Int64Array* Value::release_int64_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.int64_array)
  if (typed_value_case() == kInt64Array) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.int64_array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.int64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::Int64Array& Value::_internal_int64_array() const {
  return typed_value_case() == kInt64Array ? *_impl_.typed_value_.int64_array_ : reinterpret_cast<::kuksa::val::v2::Int64Array&>(::kuksa::val::v2::_Int64Array_default_instance_);
}
inline const ::kuksa::val::v2::Int64Array& Value::int64_array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.int64_array)
  return _internal_int64_array();
}
inline ::kuksa::val::v2::Int64Array* Value::unsafe_arena_release_int64_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.int64_array)
  if (typed_value_case() == kInt64Array) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.int64_array_;
    _impl_.typed_value_.int64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_int64_array(::kuksa::val::v2::Int64Array* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_typed_value();
  if (value) {
    set_has_int64_array();
    _impl_.typed_value_.int64_array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.int64_array)
}
inline ::kuksa::val::v2::Int64Array* Value::_internal_mutable_int64_array() {
  if (typed_value_case() != kInt64Array) {
    clear_typed_value();
    set_has_int64_array();
    _impl_.typed_value_.int64_array_ = CreateMaybeMessage<::kuksa::val::v2::Int64Array>(GetArena());
  }
  return _impl_.typed_value_.int64_array_;
}
inline ::kuksa::val::v2::Int64Array* Value::mutable_int64_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::Int64Array* _msg = _internal_mutable_int64_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.int64_array)
  return _msg;
}

// .kuksa.val.v2.Uint32Array uint32_array = 25;
inline bool Value::has_uint32_array() const {
  return typed_value_case() == kUint32Array;
}
inline bool Value::_internal_has_uint32_array() const {
  return typed_value_case() == kUint32Array;
}
inline void Value::set_has_uint32_array() {
  _impl_._oneof_case_[0] = kUint32Array;
}
inline void Value::clear_uint32_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kUint32Array) {
    if (GetArena() == nullptr) {
      delete _impl_.typed_value_.uint32_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::Uint32Array* Value::release_uint32_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.uint32_array)
  if (typed_value_case() == kUint32Array) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.uint32_array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.uint32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::Uint32Array& Value::_internal_uint32_array() const {
  return typed_value_case() == kUint32Array ? *_impl_.typed_value_.uint32_array_ : reinterpret_cast<::kuksa::val::v2::Uint32Array&>(::kuksa::val::v2::_Uint32Array_default_instance_);
}
inline const ::kuksa::val::v2::Uint32Array& Value::uint32_array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.uint32_array)
  return _internal_uint32_array();
}
inline ::kuksa::val::v2::Uint32Array* Value::unsafe_arena_release_uint32_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.uint32_array)
  if (typed_value_case() == kUint32Array) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.uint32_array_;
    _impl_.typed_value_.uint32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_uint32_array(::kuksa::val::v2::Uint32Array* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_typed_value();
  if (value) {
    set_has_uint32_array();
    _impl_.typed_value_.uint32_array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.uint32_array)
}
inline ::kuksa::val::v2::Uint32Array* Value::_internal_mutable_uint32_array() {
  if (typed_value_case() != kUint32Array) {
    clear_typed_value();
    set_has_uint32_array();
    _impl_.typed_value_.uint32_array_ = CreateMaybeMessage<::kuksa::val::v2::Uint32Array>(GetArena());
  }
  return _impl_.typed_value_.uint32_array_;
}
inline ::kuksa::val::v2::Uint32Array* Value::mutable_uint32_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::Uint32Array* _msg = _internal_mutable_uint32_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.uint32_array)
  return _msg;
}

// .kuksa.val.v2.Uint64Array uint64_array = 26;
inline bool Value::has_uint64_array() const {
  return typed_value_case() == kUint64Array;
}
inline bool Value::_internal_has_uint64_array() const {
  return typed_value_case() == kUint64Array;
}
inline void Value::set_has_uint64_array() {
  _impl_._oneof_case_[0] = kUint64Array;
}
inline void Value::clear_uint64_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kUint64Array) {
    if (GetArena() == nullptr) {
      delete _impl_.typed_value_.uint64_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::Uint64Array* Value::release_uint64_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.uint64_array)
  if (typed_value_case() == kUint64Array) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.uint64_array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.uint64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::Uint64Array& Value::_internal_uint64_array() const {
  return typed_value_case() == kUint64Array ? *_impl_.typed_value_.uint64_array_ : reinterpret_cast<::kuksa::val::v2::Uint64Array&>(::kuksa::val::v2::_Uint64Array_default_instance_);
}
inline const ::kuksa::val::v2::Uint64Array& Value::uint64_array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.uint64_array)
  return _internal_uint64_array();
}
inline ::kuksa::val::v2::Uint64Array* Value::unsafe_arena_release_uint64_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.uint64_array)
  if (typed_value_case() == kUint64Array) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.uint64_array_;
    _impl_.typed_value_.uint64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_uint64_array(::kuksa::val::v2::Uint64Array* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_typed_value();
  if (value) {
    set_has_uint64_array();
    _impl_.typed_value_.uint64_array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.uint64_array)
}
inline ::kuksa::val::v2::Uint64Array* Value::_internal_mutable_uint64_array() {
  if (typed_value_case() != kUint64Array) {
    clear_typed_value();
    set_has_uint64_array();
    _impl_.typed_value_.uint64_array_ = CreateMaybeMessage<::kuksa::val::v2::Uint64Array>(GetArena());
  }
  return _impl_.typed_value_.uint64_array_;
}
inline ::kuksa::val::v2::Uint64Array* Value::mutable_uint64_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::Uint64Array* _msg = _internal_mutable_uint64_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.uint64_array)
  return _msg;
}

// .kuksa.val.v2.FloatArray float_array = 27;
inline bool Value::has_float_array() const {
  return typed_value_case() == kFloatArray;
}
inline bool Value::_internal_has_float_array() const {
  return typed_value_case() == kFloatArray;
}
inline void Value::set_has_float_array() {
  _impl_._oneof_case_[0] = kFloatArray;
}
inline void Value::clear_float_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kFloatArray) {
    if (GetArena() == nullptr) {
      delete _impl_.typed_value_.float_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::FloatArray* Value::release_float_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.float_array)
  if (typed_value_case() == kFloatArray) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.float_array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.float_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::FloatArray& Value::_internal_float_array() const {
  return typed_value_case() == kFloatArray ? *_impl_.typed_value_.float_array_ : reinterpret_cast<::kuksa::val::v2::FloatArray&>(::kuksa::val::v2::_FloatArray_default_instance_);
}
inline const ::kuksa::val::v2::FloatArray& Value::float_array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.float_array)
  return _internal_float_array();
}
inline ::kuksa::val::v2::FloatArray* Value::unsafe_arena_release_float_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.float_array)
  if (typed_value_case() == kFloatArray) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.float_array_;
    _impl_.typed_value_.float_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_float_array(::kuksa::val::v2::FloatArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_typed_value();
  if (value) {
    set_has_float_array();
    _impl_.typed_value_.float_array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.float_array)
}
inline ::kuksa::val::v2::FloatArray* Value::_internal_mutable_float_array() {
  if (typed_value_case() != kFloatArray) {
    clear_typed_value();
    set_has_float_array();
    _impl_.typed_value_.float_array_ = CreateMaybeMessage<::kuksa::val::v2::FloatArray>(GetArena());
  }
  return _impl_.typed_value_.float_array_;
}
inline ::kuksa::val::v2::FloatArray* Value::mutable_float_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::FloatArray* _msg = _internal_mutable_float_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.float_array)
  return _msg;
}

// .kuksa.val.v2.DoubleArray double_array = 28;
inline bool Value::has_double_array() const {
  return typed_value_case() == kDoubleArray;
}
inline bool Value::_internal_has_double_array() const {
  return typed_value_case() == kDoubleArray;
}
inline void Value::set_has_double_array() {
  _impl_._oneof_case_[0] = kDoubleArray;
}
inline void Value::clear_double_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kDoubleArray) {
    if (GetArena() == nullptr) {
      delete _impl_.typed_value_.double_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::DoubleArray* Value::release_double_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.double_array)
  if (typed_value_case() == kDoubleArray) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.double_array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.double_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::DoubleArray& Value::_internal_double_array() const {
  return typed_value_case() == kDoubleArray ? *_impl_.typed_value_.double_array_ : reinterpret_cast<::kuksa::val::v2::DoubleArray&>(::kuksa::val::v2::_DoubleArray_default_instance_);
}
inline const ::kuksa::val::v2::DoubleArray& Value::double_array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.double_array)
  return _internal_double_array();
}
inline ::kuksa::val::v2::DoubleArray* Value::unsafe_arena_release_double_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.double_array)
  if (typed_value_case() == kDoubleArray) {
    clear_has_typed_value();
    auto* temp = _impl_.typed_value_.double_array_;
    _impl_.typed_value_.double_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_double_array(::kuksa::val::v2::DoubleArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_typed_value();
  if (value) {
    set_has_double_array();
    _impl_.typed_value_.double_array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.double_array)
}
inline ::kuksa::val::v2::DoubleArray* Value::_internal_mutable_double_array() {
  if (typed_value_case() != kDoubleArray) {
    clear_typed_value();
    set_has_double_array();
    _impl_.typed_value_.double_array_ = CreateMaybeMessage<::kuksa::val::v2::DoubleArray>(GetArena());
  }
  return _impl_.typed_value_.double_array_;
}
inline ::kuksa::val::v2::DoubleArray* Value::mutable_double_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::DoubleArray* _msg = _internal_mutable_double_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.double_array)
  return _msg;
}

inline bool Value::has_typed_value() const {
  return typed_value_case() != TYPED_VALUE_NOT_SET;
}
inline void Value::clear_has_typed_value() {
  _impl_._oneof_case_[0] = TYPED_VALUE_NOT_SET;
}
inline Value::TypedValueCase Value::typed_value_case() const {
  return Value::TypedValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SampleInterval

// uint32 interval_ms = 1;
inline void SampleInterval::clear_interval_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interval_ms_ = 0u;
}
inline ::uint32_t SampleInterval::interval_ms() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.SampleInterval.interval_ms)
  return _internal_interval_ms();
}
inline void SampleInterval::set_interval_ms(::uint32_t value) {
  _internal_set_interval_ms(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SampleInterval.interval_ms)
}
inline ::uint32_t SampleInterval::_internal_interval_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interval_ms_;
}
inline void SampleInterval::_internal_set_interval_ms(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interval_ms_ = value;
}

// -------------------------------------------------------------------

// Filter

// uint32 duration_ms = 1;
inline void Filter::clear_duration_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_ms_ = 0u;
}
inline ::uint32_t Filter::duration_ms() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Filter.duration_ms)
  return _internal_duration_ms();
}
inline void Filter::set_duration_ms(::uint32_t value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Filter.duration_ms)
}
inline ::uint32_t Filter::_internal_duration_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_ms_;
}
inline void Filter::_internal_set_duration_ms(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_ms_ = value;
}

// .kuksa.val.v2.SampleInterval min_sample_interval = 2;
inline bool Filter::has_min_sample_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_sample_interval_ != nullptr);
  return value;
}
inline void Filter::clear_min_sample_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.min_sample_interval_ != nullptr) _impl_.min_sample_interval_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kuksa::val::v2::SampleInterval& Filter::_internal_min_sample_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kuksa::val::v2::SampleInterval* p = _impl_.min_sample_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::SampleInterval&>(::kuksa::val::v2::_SampleInterval_default_instance_);
}
inline const ::kuksa::val::v2::SampleInterval& Filter::min_sample_interval() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Filter.min_sample_interval)
  return _internal_min_sample_interval();
}
inline void Filter::unsafe_arena_set_allocated_min_sample_interval(::kuksa::val::v2::SampleInterval* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_sample_interval_);
  }
  _impl_.min_sample_interval_ = reinterpret_cast<::kuksa::val::v2::SampleInterval*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Filter.min_sample_interval)
}
inline ::kuksa::val::v2::SampleInterval* Filter::release_min_sample_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kuksa::val::v2::SampleInterval* released = _impl_.min_sample_interval_;
  _impl_.min_sample_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kuksa::val::v2::SampleInterval* Filter::unsafe_arena_release_min_sample_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Filter.min_sample_interval)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kuksa::val::v2::SampleInterval* temp = _impl_.min_sample_interval_;
  _impl_.min_sample_interval_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::SampleInterval* Filter::_internal_mutable_min_sample_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.min_sample_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::SampleInterval>(GetArena());
    _impl_.min_sample_interval_ = reinterpret_cast<::kuksa::val::v2::SampleInterval*>(p);
  }
  return _impl_.min_sample_interval_;
}
inline ::kuksa::val::v2::SampleInterval* Filter::mutable_min_sample_interval() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::SampleInterval* _msg = _internal_mutable_min_sample_interval();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Filter.min_sample_interval)
  return _msg;
}
inline void Filter::set_allocated_min_sample_interval(::kuksa::val::v2::SampleInterval* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::kuksa::val::v2::SampleInterval*>(_impl_.min_sample_interval_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::kuksa::val::v2::SampleInterval*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.min_sample_interval_ = reinterpret_cast<::kuksa::val::v2::SampleInterval*>(value);
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Filter.min_sample_interval)
}

// -------------------------------------------------------------------

// SignalID

// int32 id = 1;
inline bool SignalID::has_id() const {
  return signal_case() == kId;
}
inline void SignalID::set_has_id() {
  _impl_._oneof_case_[0] = kId;
}
inline void SignalID::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (signal_case() == kId) {
    _impl_.signal_.id_ = 0;
    clear_has_signal();
  }
}
inline ::int32_t SignalID::id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.SignalID.id)
  return _internal_id();
}
inline void SignalID::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SignalID.id)
}
inline ::int32_t SignalID::_internal_id() const {
  if (signal_case() == kId) {
    return _impl_.signal_.id_;
  }
  return 0;
}
inline void SignalID::_internal_set_id(::int32_t value) {
  if (signal_case() != kId) {
    clear_signal();
    set_has_id();
  }
  _impl_.signal_.id_ = value;
}

// string path = 2;
inline bool SignalID::has_path() const {
  return signal_case() == kPath;
}
inline void SignalID::set_has_path() {
  _impl_._oneof_case_[0] = kPath;
}
inline void SignalID::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (signal_case() == kPath) {
    _impl_.signal_.path_.Destroy();
    clear_has_signal();
  }
}
inline const std::string& SignalID::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.SignalID.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignalID::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (signal_case() != kPath) {
    clear_signal();

    set_has_path();
    _impl_.signal_.path_.InitDefault();
  }
  _impl_.signal_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SignalID.path)
}
inline std::string* SignalID::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.SignalID.path)
  return _s;
}
inline const std::string& SignalID::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (signal_case() != kPath) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.signal_.path_.Get();
}
inline void SignalID::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (signal_case() != kPath) {
    clear_signal();

    set_has_path();
    _impl_.signal_.path_.InitDefault();
  }
  _impl_.signal_.path_.Set(value, GetArena());
}
inline std::string* SignalID::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (signal_case() != kPath) {
    clear_signal();

    set_has_path();
    _impl_.signal_.path_.InitDefault();
  }
  return _impl_.signal_.path_.Mutable( GetArena());
}
inline std::string* SignalID::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.SignalID.path)
  if (signal_case() != kPath) {
    return nullptr;
  }
  clear_has_signal();
  return _impl_.signal_.path_.Release();
}
inline void SignalID::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_signal()) {
    clear_signal();
  }
  if (value != nullptr) {
    set_has_path();
    _impl_.signal_.path_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.SignalID.path)
}

inline bool SignalID::has_signal() const {
  return signal_case() != SIGNAL_NOT_SET;
}
inline void SignalID::clear_has_signal() {
  _impl_._oneof_case_[0] = SIGNAL_NOT_SET;
}
inline SignalID::SignalCase SignalID::signal_case() const {
  return SignalID::SignalCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Error

// .kuksa.val.v2.ErrorCode code = 1;
inline void Error::clear_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_ = 0;
}
inline ::kuksa::val::v2::ErrorCode Error::code() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Error.code)
  return _internal_code();
}
inline void Error::set_code(::kuksa::val::v2::ErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Error.code)
}
inline ::kuksa::val::v2::ErrorCode Error::_internal_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::kuksa::val::v2::ErrorCode>(_impl_.code_);
}
inline void Error::_internal_set_code(::kuksa::val::v2::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.code_ = value;
}

// string message = 2;
inline void Error::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Error::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Error.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Error::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Error.message)
}
inline std::string* Error::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* Error::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* Error::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Error.message)
  return _impl_.message_.Release();
}
inline void Error::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Error.message)
}

// -------------------------------------------------------------------

// Metadata

// string path = 9;
inline void Metadata::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Metadata::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Metadata::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.path)
}
inline std::string* Metadata::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.path)
  return _s;
}
inline const std::string& Metadata::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void Metadata::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* Metadata::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* Metadata::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.path)
  return _impl_.path_.Release();
}
inline void Metadata::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.path)
}

// int32 id = 10;
inline void Metadata::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Metadata::id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.id)
  return _internal_id();
}
inline void Metadata::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.id)
}
inline ::int32_t Metadata::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Metadata::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .kuksa.val.v2.DataType data_type = 11;
inline void Metadata::clear_data_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_type_ = 0;
}
inline ::kuksa::val::v2::DataType Metadata::data_type() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.data_type)
  return _internal_data_type();
}
inline void Metadata::set_data_type(::kuksa::val::v2::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.data_type)
}
inline ::kuksa::val::v2::DataType Metadata::_internal_data_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::kuksa::val::v2::DataType>(_impl_.data_type_);
}
inline void Metadata::_internal_set_data_type(::kuksa::val::v2::DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_type_ = value;
}

// .kuksa.val.v2.EntryType entry_type = 12;
inline void Metadata::clear_entry_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entry_type_ = 0;
}
inline ::kuksa::val::v2::EntryType Metadata::entry_type() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.entry_type)
  return _internal_entry_type();
}
inline void Metadata::set_entry_type(::kuksa::val::v2::EntryType value) {
  _internal_set_entry_type(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.entry_type)
}
inline ::kuksa::val::v2::EntryType Metadata::_internal_entry_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::kuksa::val::v2::EntryType>(_impl_.entry_type_);
}
inline void Metadata::_internal_set_entry_type(::kuksa::val::v2::EntryType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entry_type_ = value;
}

// string description = 13;
inline void Metadata::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Metadata::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Metadata::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.description)
}
inline std::string* Metadata::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.description)
  return _s;
}
inline const std::string& Metadata::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void Metadata::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Metadata::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Metadata::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.description)
  return _impl_.description_.Release();
}
inline void Metadata::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.description)
}

// string comment = 14;
inline void Metadata::clear_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Metadata::comment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.comment)
  return _internal_comment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Metadata::set_comment(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.comment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.comment)
}
inline std::string* Metadata::mutable_comment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.comment)
  return _s;
}
inline const std::string& Metadata::_internal_comment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.comment_.Get();
}
inline void Metadata::_internal_set_comment(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.comment_.Set(value, GetArena());
}
inline std::string* Metadata::_internal_mutable_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.comment_.Mutable( GetArena());
}
inline std::string* Metadata::release_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.comment)
  return _impl_.comment_.Release();
}
inline void Metadata::set_allocated_comment(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comment_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comment_.IsDefault()) {
          _impl_.comment_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.comment)
}

// string deprecation = 15;
inline void Metadata::clear_deprecation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deprecation_.ClearToEmpty();
}
inline const std::string& Metadata::deprecation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.deprecation)
  return _internal_deprecation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Metadata::set_deprecation(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.deprecation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.deprecation)
}
inline std::string* Metadata::mutable_deprecation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_deprecation();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.deprecation)
  return _s;
}
inline const std::string& Metadata::_internal_deprecation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deprecation_.Get();
}
inline void Metadata::_internal_set_deprecation(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.deprecation_.Set(value, GetArena());
}
inline std::string* Metadata::_internal_mutable_deprecation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.deprecation_.Mutable( GetArena());
}
inline std::string* Metadata::release_deprecation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.deprecation)
  return _impl_.deprecation_.Release();
}
inline void Metadata::set_allocated_deprecation(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deprecation_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deprecation_.IsDefault()) {
          _impl_.deprecation_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.deprecation)
}

// string unit = 16;
inline void Metadata::clear_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unit_.ClearToEmpty();
}
inline const std::string& Metadata::unit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.unit)
  return _internal_unit();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Metadata::set_unit(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.unit)
}
inline std::string* Metadata::mutable_unit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.unit)
  return _s;
}
inline const std::string& Metadata::_internal_unit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unit_.Get();
}
inline void Metadata::_internal_set_unit(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unit_.Set(value, GetArena());
}
inline std::string* Metadata::_internal_mutable_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.unit_.Mutable( GetArena());
}
inline std::string* Metadata::release_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.unit)
  return _impl_.unit_.Release();
}
inline void Metadata::set_allocated_unit(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unit_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unit_.IsDefault()) {
          _impl_.unit_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.unit)
}

// .kuksa.val.v2.Value allowed_values = 17;
inline bool Metadata::has_allowed_values() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.allowed_values_ != nullptr);
  return value;
}
inline void Metadata::clear_allowed_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.allowed_values_ != nullptr) _impl_.allowed_values_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kuksa::val::v2::Value& Metadata::_internal_allowed_values() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kuksa::val::v2::Value* p = _impl_.allowed_values_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Value&>(::kuksa::val::v2::_Value_default_instance_);
}
inline const ::kuksa::val::v2::Value& Metadata::allowed_values() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.allowed_values)
  return _internal_allowed_values();
}
inline void Metadata::unsafe_arena_set_allocated_allowed_values(::kuksa::val::v2::Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.allowed_values_);
  }
  _impl_.allowed_values_ = reinterpret_cast<::kuksa::val::v2::Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Metadata.allowed_values)
}
inline ::kuksa::val::v2::Value* Metadata::release_allowed_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kuksa::val::v2::Value* released = _impl_.allowed_values_;
  _impl_.allowed_values_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kuksa::val::v2::Value* Metadata::unsafe_arena_release_allowed_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.allowed_values)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kuksa::val::v2::Value* temp = _impl_.allowed_values_;
  _impl_.allowed_values_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Value* Metadata::_internal_mutable_allowed_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.allowed_values_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Value>(GetArena());
    _impl_.allowed_values_ = reinterpret_cast<::kuksa::val::v2::Value*>(p);
  }
  return _impl_.allowed_values_;
}
inline ::kuksa::val::v2::Value* Metadata::mutable_allowed_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::Value* _msg = _internal_mutable_allowed_values();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.allowed_values)
  return _msg;
}
inline void Metadata::set_allocated_allowed_values(::kuksa::val::v2::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::kuksa::val::v2::Value*>(_impl_.allowed_values_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::kuksa::val::v2::Value*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.allowed_values_ = reinterpret_cast<::kuksa::val::v2::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.allowed_values)
}

// .kuksa.val.v2.Value min = 18;
inline bool Metadata::has_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_ != nullptr);
  return value;
}
inline void Metadata::clear_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.min_ != nullptr) _impl_.min_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kuksa::val::v2::Value& Metadata::_internal_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kuksa::val::v2::Value* p = _impl_.min_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Value&>(::kuksa::val::v2::_Value_default_instance_);
}
inline const ::kuksa::val::v2::Value& Metadata::min() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.min)
  return _internal_min();
}
inline void Metadata::unsafe_arena_set_allocated_min(::kuksa::val::v2::Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_);
  }
  _impl_.min_ = reinterpret_cast<::kuksa::val::v2::Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Metadata.min)
}
inline ::kuksa::val::v2::Value* Metadata::release_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kuksa::val::v2::Value* released = _impl_.min_;
  _impl_.min_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kuksa::val::v2::Value* Metadata::unsafe_arena_release_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.min)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kuksa::val::v2::Value* temp = _impl_.min_;
  _impl_.min_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Value* Metadata::_internal_mutable_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.min_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Value>(GetArena());
    _impl_.min_ = reinterpret_cast<::kuksa::val::v2::Value*>(p);
  }
  return _impl_.min_;
}
inline ::kuksa::val::v2::Value* Metadata::mutable_min() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::Value* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.min)
  return _msg;
}
inline void Metadata::set_allocated_min(::kuksa::val::v2::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::kuksa::val::v2::Value*>(_impl_.min_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::kuksa::val::v2::Value*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.min_ = reinterpret_cast<::kuksa::val::v2::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.min)
}

// .kuksa.val.v2.Value max = 19;
inline bool Metadata::has_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_ != nullptr);
  return value;
}
inline void Metadata::clear_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.max_ != nullptr) _impl_.max_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::kuksa::val::v2::Value& Metadata::_internal_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kuksa::val::v2::Value* p = _impl_.max_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Value&>(::kuksa::val::v2::_Value_default_instance_);
}
inline const ::kuksa::val::v2::Value& Metadata::max() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.max)
  return _internal_max();
}
inline void Metadata::unsafe_arena_set_allocated_max(::kuksa::val::v2::Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_);
  }
  _impl_.max_ = reinterpret_cast<::kuksa::val::v2::Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Metadata.max)
}
inline ::kuksa::val::v2::Value* Metadata::release_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kuksa::val::v2::Value* released = _impl_.max_;
  _impl_.max_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kuksa::val::v2::Value* Metadata::unsafe_arena_release_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.max)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kuksa::val::v2::Value* temp = _impl_.max_;
  _impl_.max_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Value* Metadata::_internal_mutable_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.max_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Value>(GetArena());
    _impl_.max_ = reinterpret_cast<::kuksa::val::v2::Value*>(p);
  }
  return _impl_.max_;
}
inline ::kuksa::val::v2::Value* Metadata::mutable_max() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::Value* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.max)
  return _msg;
}
inline void Metadata::set_allocated_max(::kuksa::val::v2::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::kuksa::val::v2::Value*>(_impl_.max_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::kuksa::val::v2::Value*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.max_ = reinterpret_cast<::kuksa::val::v2::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.max)
}

// .kuksa.val.v2.SampleInterval min_sample_interval = 20;
inline bool Metadata::has_min_sample_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_sample_interval_ != nullptr);
  return value;
}
inline void Metadata::clear_min_sample_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.min_sample_interval_ != nullptr) _impl_.min_sample_interval_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::kuksa::val::v2::SampleInterval& Metadata::_internal_min_sample_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kuksa::val::v2::SampleInterval* p = _impl_.min_sample_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::SampleInterval&>(::kuksa::val::v2::_SampleInterval_default_instance_);
}
inline const ::kuksa::val::v2::SampleInterval& Metadata::min_sample_interval() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.min_sample_interval)
  return _internal_min_sample_interval();
}
inline void Metadata::unsafe_arena_set_allocated_min_sample_interval(::kuksa::val::v2::SampleInterval* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_sample_interval_);
  }
  _impl_.min_sample_interval_ = reinterpret_cast<::kuksa::val::v2::SampleInterval*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Metadata.min_sample_interval)
}
inline ::kuksa::val::v2::SampleInterval* Metadata::release_min_sample_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::kuksa::val::v2::SampleInterval* released = _impl_.min_sample_interval_;
  _impl_.min_sample_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kuksa::val::v2::SampleInterval* Metadata::unsafe_arena_release_min_sample_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.min_sample_interval)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::kuksa::val::v2::SampleInterval* temp = _impl_.min_sample_interval_;
  _impl_.min_sample_interval_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::SampleInterval* Metadata::_internal_mutable_min_sample_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.min_sample_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::SampleInterval>(GetArena());
    _impl_.min_sample_interval_ = reinterpret_cast<::kuksa::val::v2::SampleInterval*>(p);
  }
  return _impl_.min_sample_interval_;
}
inline ::kuksa::val::v2::SampleInterval* Metadata::mutable_min_sample_interval() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kuksa::val::v2::SampleInterval* _msg = _internal_mutable_min_sample_interval();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.min_sample_interval)
  return _msg;
}
inline void Metadata::set_allocated_min_sample_interval(::kuksa::val::v2::SampleInterval* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::kuksa::val::v2::SampleInterval*>(_impl_.min_sample_interval_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::kuksa::val::v2::SampleInterval*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.min_sample_interval_ = reinterpret_cast<::kuksa::val::v2::SampleInterval*>(value);
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.min_sample_interval)
}

// -------------------------------------------------------------------

// StringArray

// repeated string values = 1;
inline int StringArray::_internal_values_size() const {
  return _internal_values().size();
}
inline int StringArray::values_size() const {
  return _internal_values_size();
}
inline void StringArray::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline std::string* StringArray::add_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add_mutable:kuksa.val.v2.StringArray.values)
  return _s;
}
inline const std::string& StringArray::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.StringArray.values)
  return _internal_values().Get(index);
}
inline std::string* StringArray::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.StringArray.values)
  return _internal_mutable_values()->Mutable(index);
}
inline void StringArray::set_values(int index, const std::string& value) {
  _internal_mutable_values()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.StringArray.values)
}
inline void StringArray::set_values(int index, std::string&& value) {
  _internal_mutable_values()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kuksa.val.v2.StringArray.values)
}
inline void StringArray::set_values(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_values()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kuksa.val.v2.StringArray.values)
}
inline void StringArray::set_values(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_values()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kuksa.val.v2.StringArray.values)
}
inline void StringArray::set_values(int index, absl::string_view value) {
  _internal_mutable_values()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:kuksa.val.v2.StringArray.values)
}
inline void StringArray::add_values(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.StringArray.values)
}
inline void StringArray::add_values(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:kuksa.val.v2.StringArray.values)
}
inline void StringArray::add_values(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kuksa.val.v2.StringArray.values)
}
inline void StringArray::add_values(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kuksa.val.v2.StringArray.values)
}
inline void StringArray::add_values(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:kuksa.val.v2.StringArray.values)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringArray::values() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.StringArray.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringArray::mutable_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.StringArray.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringArray::_internal_values() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringArray::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BoolArray

// repeated bool values = 1;
inline int BoolArray::_internal_values_size() const {
  return _internal_values().size();
}
inline int BoolArray::values_size() const {
  return _internal_values_size();
}
inline void BoolArray::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline bool BoolArray::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.BoolArray.values)
  return _internal_values().Get(index);
}
inline void BoolArray::set_values(int index, bool value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.BoolArray.values)
}
inline void BoolArray::add_values(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.BoolArray.values)
}
inline const ::google::protobuf::RepeatedField<bool>& BoolArray::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.BoolArray.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<bool>* BoolArray::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.BoolArray.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<bool>& BoolArray::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<bool>* BoolArray::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Int32Array

// repeated sint32 values = 1;
inline int Int32Array::_internal_values_size() const {
  return _internal_values().size();
}
inline int Int32Array::values_size() const {
  return _internal_values_size();
}
inline void Int32Array::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::int32_t Int32Array::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Int32Array.values)
  return _internal_values().Get(index);
}
inline void Int32Array::set_values(int index, ::int32_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Int32Array.values)
}
inline void Int32Array::add_values(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.Int32Array.values)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Array::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.Int32Array.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Array::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.Int32Array.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Array::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Array::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Int64Array

// repeated sint64 values = 1;
inline int Int64Array::_internal_values_size() const {
  return _internal_values().size();
}
inline int Int64Array::values_size() const {
  return _internal_values_size();
}
inline void Int64Array::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::int64_t Int64Array::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Int64Array.values)
  return _internal_values().Get(index);
}
inline void Int64Array::set_values(int index, ::int64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Int64Array.values)
}
inline void Int64Array::add_values(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.Int64Array.values)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Array::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.Int64Array.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Array::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.Int64Array.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Array::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Array::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Uint32Array

// repeated uint32 values = 1;
inline int Uint32Array::_internal_values_size() const {
  return _internal_values().size();
}
inline int Uint32Array::values_size() const {
  return _internal_values_size();
}
inline void Uint32Array::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::uint32_t Uint32Array::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Uint32Array.values)
  return _internal_values().Get(index);
}
inline void Uint32Array::set_values(int index, ::uint32_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Uint32Array.values)
}
inline void Uint32Array::add_values(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.Uint32Array.values)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Uint32Array::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.Uint32Array.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Uint32Array::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.Uint32Array.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Uint32Array::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Uint32Array::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Uint64Array

// repeated uint64 values = 1;
inline int Uint64Array::_internal_values_size() const {
  return _internal_values().size();
}
inline int Uint64Array::values_size() const {
  return _internal_values_size();
}
inline void Uint64Array::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::uint64_t Uint64Array::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Uint64Array.values)
  return _internal_values().Get(index);
}
inline void Uint64Array::set_values(int index, ::uint64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Uint64Array.values)
}
inline void Uint64Array::add_values(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.Uint64Array.values)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Uint64Array::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.Uint64Array.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Uint64Array::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.Uint64Array.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Uint64Array::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Uint64Array::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// FloatArray

// repeated float values = 1;
inline int FloatArray::_internal_values_size() const {
  return _internal_values().size();
}
inline int FloatArray::values_size() const {
  return _internal_values_size();
}
inline void FloatArray::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline float FloatArray::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.FloatArray.values)
  return _internal_values().Get(index);
}
inline void FloatArray::set_values(int index, float value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.FloatArray.values)
}
inline void FloatArray::add_values(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.FloatArray.values)
}
inline const ::google::protobuf::RepeatedField<float>& FloatArray::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.FloatArray.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<float>* FloatArray::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.FloatArray.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<float>& FloatArray::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<float>* FloatArray::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// DoubleArray

// repeated double values = 1;
inline int DoubleArray::_internal_values_size() const {
  return _internal_values().size();
}
inline int DoubleArray::values_size() const {
  return _internal_values_size();
}
inline void DoubleArray::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline double DoubleArray::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.DoubleArray.values)
  return _internal_values().Get(index);
}
inline void DoubleArray::set_values(int index, double value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.DoubleArray.values)
}
inline void DoubleArray::add_values(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.DoubleArray.values)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleArray::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.DoubleArray.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<double>* DoubleArray::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.DoubleArray.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<double>& DoubleArray::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<double>* DoubleArray::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v2
}  // namespace val
}  // namespace kuksa


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::kuksa::val::v2::FilterError> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kuksa::val::v2::FilterError>() {
  return ::kuksa::val::v2::FilterError_descriptor();
}
template <>
struct is_proto_enum<::kuksa::val::v2::ProviderError> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kuksa::val::v2::ProviderError>() {
  return ::kuksa::val::v2::ProviderError_descriptor();
}
template <>
struct is_proto_enum<::kuksa::val::v2::ErrorCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kuksa::val::v2::ErrorCode>() {
  return ::kuksa::val::v2::ErrorCode_descriptor();
}
template <>
struct is_proto_enum<::kuksa::val::v2::DataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kuksa::val::v2::DataType>() {
  return ::kuksa::val::v2::DataType_descriptor();
}
template <>
struct is_proto_enum<::kuksa::val::v2::EntryType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kuksa::val::v2::EntryType>() {
  return ::kuksa::val::v2::EntryType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_kuksa_2fval_2fv2_2ftypes_2eproto_2epb_2eh
