// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: kuksa/val/v2/val.proto
// Original file comments:
// *******************************************************************************
// Copyright (c) 2024 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available under the
// terms of the Apache License 2.0 which is available at
// http://www.apache.org/licenses/LICENSE-2.0
//
// SPDX-License-Identifier: Apache-2.0
// ******************************************************************************
//
#ifndef GRPC_kuksa_2fval_2fv2_2fval_2eproto__INCLUDED
#define GRPC_kuksa_2fval_2fv2_2fval_2eproto__INCLUDED

#include "val.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace kuksa {
namespace val {
namespace v2 {

class VAL final {
 public:
  static constexpr char const* service_full_name() {
    return "kuksa.val.v2.VAL";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Get the latest value of a signal
    // If the signal exist but does not have a valid value
    // a DataPoint where value is None shall be returned.
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if the requested signal doesn't exist
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   PERMISSION_DENIED if access is denied
    //   INVALID_ARGUMENT if the request is empty or provided path is too long
    //     - MAX_REQUEST_PATH_LENGTH: usize = 1000;
    //
    virtual ::grpc::Status GetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::kuksa::val::v2::GetValueResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValueResponse>> AsyncGetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValueResponse>>(AsyncGetValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValueResponse>> PrepareAsyncGetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValueResponse>>(PrepareAsyncGetValueRaw(context, request, cq));
    }
    // Get the latest values of a set of signals.
    // The returned list of data points has the same order as the list of the request.
    // If a requested signal has no value a DataPoint where value is None will be returned.
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the requested signals doesn't exist.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   PERMISSION_DENIED if access is denied for any of the requested signals.
    //   INVALID_ARGUMENT if the request is empty or provided path is too long
    //     - MAX_REQUEST_PATH_LENGTH: usize = 1000;
    //
    virtual ::grpc::Status GetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::kuksa::val::v2::GetValuesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValuesResponse>> AsyncGetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValuesResponse>>(AsyncGetValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValuesResponse>> PrepareAsyncGetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValuesResponse>>(PrepareAsyncGetValuesRaw(context, request, cq));
    }
    // Subscribe to a set of signals using string path parameters
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the signals are non-existant.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   PERMISSION_DENIED if access is denied for any of the signals.
    //   INVALID_ARGUMENT
    //     - if the request is empty or provided path is too long
    //       MAX_REQUEST_PATH_LENGTH: usize = 1000;
    //     - if buffer_size exceeds the maximum permitted
    //       MAX_BUFFER_SIZE: usize = 1000;
    //
    // When subscribing, Databroker shall immediately return the value for all
    // subscribed entries.
    // If a value isn't available when subscribing to a it, it should return None
    //
    // If a subscriber is slow to consume signals, messages will be buffered up
    // to the specified buffer_size before the oldest messages are dropped.
    //
    std::unique_ptr< ::grpc::ClientReaderInterface< ::kuksa::val::v2::SubscribeResponse>> Subscribe(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::kuksa::val::v2::SubscribeResponse>>(SubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeResponse>> AsyncSubscribe(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeResponse>>(AsyncSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeResponse>> PrepareAsyncSubscribe(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeResponse>>(PrepareAsyncSubscribeRaw(context, request, cq));
    }
    // Subscribe to a set of signals using i32 id parameters
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the signals are non-existant.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   PERMISSION_DENIED if access is denied for any of the signals.
    //   INVALID_ARGUMENT
    //     - if the request is empty or provided path is too long
    //       MAX_REQUEST_PATH_LENGTH: usize = 1000;
    //     - if buffer_size exceeds the maximum permitted
    //       MAX_BUFFER_SIZE: usize = 1000;
    //
    // When subscribing, Databroker shall immediately return the value for all
    // subscribed entries.
    // If a value isn't available when subscribing to a it, it should return None
    //
    // If a subscriber is slow to consume signals, messages will be buffered up
    // to the specified buffer_size before the oldest messages are dropped.
    //
    std::unique_ptr< ::grpc::ClientReaderInterface< ::kuksa::val::v2::SubscribeByIdResponse>> SubscribeById(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::kuksa::val::v2::SubscribeByIdResponse>>(SubscribeByIdRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeByIdResponse>> AsyncSubscribeById(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeByIdResponse>>(AsyncSubscribeByIdRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeByIdResponse>> PrepareAsyncSubscribeById(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeByIdResponse>>(PrepareAsyncSubscribeByIdRaw(context, request, cq));
    }
    // Actuate a single actuator
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if the actuator does not exist.
    //   PERMISSION_DENIED if access is denied for the actuator.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   UNAVAILABLE if there is no provider currently providing the actuator
    //   DATA_LOSS is there is a internal TransmissionFailure
    //   INVALID_ARGUMENT
    //     - if the provided path is not an actuator.
    //     - if the data type used in the request does not match
    //       the data type of the addressed signal
    //     - if the requested value is not accepted,
    //       e.g. if sending an unsupported enum value
    //     - if the provided value is out of the min/max range specified
    //
    virtual ::grpc::Status Actuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::kuksa::val::v2::ActuateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ActuateResponse>> AsyncActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ActuateResponse>>(AsyncActuateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ActuateResponse>> PrepareAsyncActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ActuateResponse>>(PrepareAsyncActuateRaw(context, request, cq));
    }
    // Actuate a single actuator in a gRPC stream -> Use for low latency and high throughput
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if the actuator does not exist.
    //   PERMISSION_DENIED if access is denied for the actuator.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   UNAVAILABLE if there is no provider currently providing the actuator
    //   DATA_LOSS is there is a internal TransmissionFailure
    //   INVALID_ARGUMENT
    //     - if the provided path is not an actuator.
    //     - if the data type used in the request does not match
    //       the data type of the addressed signal
    //     - if the requested value is not accepted,
    //       e.g. if sending an unsupported enum value
    //     - if the provided value is out of the min/max range specified
    //
    std::unique_ptr< ::grpc::ClientWriterInterface< ::kuksa::val::v2::ActuateRequest>> ActuateStream(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::kuksa::val::v2::ActuateRequest>>(ActuateStreamRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::kuksa::val::v2::ActuateRequest>> AsyncActuateStream(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::kuksa::val::v2::ActuateRequest>>(AsyncActuateStreamRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::kuksa::val::v2::ActuateRequest>> PrepareAsyncActuateStream(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::kuksa::val::v2::ActuateRequest>>(PrepareAsyncActuateStreamRaw(context, response, cq));
    }
    // Actuate simultaneously multiple actuators.
    // If any error occurs, the entire operation will be aborted
    // and no single actuator value will be forwarded to the provider.
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the actuators are non-existant.
    //   PERMISSION_DENIED if access is denied for any of the actuators.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   UNAVAILABLE if there is no provider currently providing an actuator
    //   DATA_LOSS is there is a internal TransmissionFailure
    //   INVALID_ARGUMENT
    //     - if any of the provided path is not an actuator.
    //     - if the data type used in the request does not match
    //       the data type of the addressed signal
    //     - if the requested value is not accepted,
    //       e.g. if sending an unsupported enum value
    //     - if any of the provided actuators values are out of the min/max range specified
    //
    virtual ::grpc::Status BatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::kuksa::val::v2::BatchActuateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::BatchActuateResponse>> AsyncBatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::BatchActuateResponse>>(AsyncBatchActuateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::BatchActuateResponse>> PrepareAsyncBatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::BatchActuateResponse>>(PrepareAsyncBatchActuateRaw(context, request, cq));
    }
    // List metadata of signals matching the request.
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if the specified root branch does not exist.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   INVALID_ARGUMENT if the provided path or wildcard is wrong.
    //
    virtual ::grpc::Status ListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::kuksa::val::v2::ListMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ListMetadataResponse>> AsyncListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ListMetadataResponse>>(AsyncListMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ListMetadataResponse>> PrepareAsyncListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ListMetadataResponse>>(PrepareAsyncListMetadataRaw(context, request, cq));
    }
    // Publish a signal value. Used for low frequency signals (e.g. attributes).
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the signals are non-existant.
    //   PERMISSION_DENIED
    //     - if access is denied for any of the signals.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   INVALID_ARGUMENT
    //     - if the data type used in the request does not match
    //       the data type of the addressed signal
    //     - if the published value is not accepted,
    //       e.g. if sending an unsupported enum value
    //     - if the published value is out of the min/max range specified
    //
    virtual ::grpc::Status PublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::kuksa::val::v2::PublishValueResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::PublishValueResponse>> AsyncPublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::PublishValueResponse>>(AsyncPublishValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::PublishValueResponse>> PrepareAsyncPublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::PublishValueResponse>>(PrepareAsyncPublishValueRaw(context, request, cq));
    }
    // Open a stream used to provide actuation and/or publishing values using
    // a streaming interface. Used to provide actuators and to enable high frequency
    // updates of values.
    //
    // The open stream is used for request / response type communication between the
    // provider and server (where the initiator of a request can vary).
    //
    // Errors:
    //  - Provider sends ProvideActuationRequest -> Databroker returns ProvideActuationResponse.
    //    Possible gRPC error codes:
    //    - NOT_FOUND if any of the signals do not exist.
    //    - PERMISSION_DENIED if access is denied for any of the signals.
    //    - UNAUTHENTICATED if no credentials are provided or if they have expired.
    //    - ALREADY_EXISTS if a provider already claimed ownership of an actuator.
    //
    //  - Provider sends PublishValuesRequest -> Databroker returns PublishValuesResponse
    //    upon error, and nothing upon success. Errors are returned as messages in the
    //    stream response with signal id `map<int32, Error> status = 2;` (permissive case).
    //    Possible error codes:
    //    - NOT_FOUND if a signal does not exist.
    //    - PERMISSION_DENIED if access is denied for a signal.
    //    - INVALID_ARGUMENT if:
    //      - The data type used in the request does not match the signal's data type.
    //      - The published value is unsupported (e.g., sending an invalid enum value).
    //      - The published value is out of the specified min/max range.
    //
    //  - Databroker sends BatchActuateStreamRequest -> Provider must return
    //    BatchActuateStreamResponse for each requested signal to indicate acceptance or rejection.
    //    It is up to the provider to decide if the stream shall be closed. The databroker
    //    will not react to the received error message.
    //
    //  - Provider sends ProvideSignalRequest -> Databroker returns ProvideSignalResponse.
    //    Possible gRPC error codes:
    //    - NOT_FOUND if any signals do not exist.
    //    - PERMISSION_DENIED if access is denied for any of the signals.
    //    - UNAUTHENTICATED if no credentials are provided or if they have expired.
    //    - ALREADY_EXISTS if a provider has already claimed ownership of any signal.
    //
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>> OpenProviderStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>>(OpenProviderStreamRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>> AsyncOpenProviderStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>>(AsyncOpenProviderStreamRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>> PrepareAsyncOpenProviderStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>>(PrepareAsyncOpenProviderStreamRaw(context, cq));
    }
    // Get server information
    virtual ::grpc::Status GetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::kuksa::val::v2::GetServerInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetServerInfoResponse>> AsyncGetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetServerInfoResponse>>(AsyncGetServerInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetServerInfoResponse>> PrepareAsyncGetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetServerInfoResponse>>(PrepareAsyncGetServerInfoRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Get the latest value of a signal
      // If the signal exist but does not have a valid value
      // a DataPoint where value is None shall be returned.
      //
      // Returns (GRPC error code):
      //   NOT_FOUND if the requested signal doesn't exist
      //   UNAUTHENTICATED if no credentials provided or credentials has expired
      //   PERMISSION_DENIED if access is denied
      //   INVALID_ARGUMENT if the request is empty or provided path is too long
      //     - MAX_REQUEST_PATH_LENGTH: usize = 1000;
      //
      virtual void GetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest* request, ::kuksa::val::v2::GetValueResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest* request, ::kuksa::val::v2::GetValueResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the latest values of a set of signals.
      // The returned list of data points has the same order as the list of the request.
      // If a requested signal has no value a DataPoint where value is None will be returned.
      //
      // Returns (GRPC error code):
      //   NOT_FOUND if any of the requested signals doesn't exist.
      //   UNAUTHENTICATED if no credentials provided or credentials has expired
      //   PERMISSION_DENIED if access is denied for any of the requested signals.
      //   INVALID_ARGUMENT if the request is empty or provided path is too long
      //     - MAX_REQUEST_PATH_LENGTH: usize = 1000;
      //
      virtual void GetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest* request, ::kuksa::val::v2::GetValuesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest* request, ::kuksa::val::v2::GetValuesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Subscribe to a set of signals using string path parameters
      // Returns (GRPC error code):
      //   NOT_FOUND if any of the signals are non-existant.
      //   UNAUTHENTICATED if no credentials provided or credentials has expired
      //   PERMISSION_DENIED if access is denied for any of the signals.
      //   INVALID_ARGUMENT
      //     - if the request is empty or provided path is too long
      //       MAX_REQUEST_PATH_LENGTH: usize = 1000;
      //     - if buffer_size exceeds the maximum permitted
      //       MAX_BUFFER_SIZE: usize = 1000;
      //
      // When subscribing, Databroker shall immediately return the value for all
      // subscribed entries.
      // If a value isn't available when subscribing to a it, it should return None
      //
      // If a subscriber is slow to consume signals, messages will be buffered up
      // to the specified buffer_size before the oldest messages are dropped.
      //
      virtual void Subscribe(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest* request, ::grpc::ClientReadReactor< ::kuksa::val::v2::SubscribeResponse>* reactor) = 0;
      // Subscribe to a set of signals using i32 id parameters
      // Returns (GRPC error code):
      //   NOT_FOUND if any of the signals are non-existant.
      //   UNAUTHENTICATED if no credentials provided or credentials has expired
      //   PERMISSION_DENIED if access is denied for any of the signals.
      //   INVALID_ARGUMENT
      //     - if the request is empty or provided path is too long
      //       MAX_REQUEST_PATH_LENGTH: usize = 1000;
      //     - if buffer_size exceeds the maximum permitted
      //       MAX_BUFFER_SIZE: usize = 1000;
      //
      // When subscribing, Databroker shall immediately return the value for all
      // subscribed entries.
      // If a value isn't available when subscribing to a it, it should return None
      //
      // If a subscriber is slow to consume signals, messages will be buffered up
      // to the specified buffer_size before the oldest messages are dropped.
      //
      virtual void SubscribeById(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest* request, ::grpc::ClientReadReactor< ::kuksa::val::v2::SubscribeByIdResponse>* reactor) = 0;
      // Actuate a single actuator
      //
      // Returns (GRPC error code):
      //   NOT_FOUND if the actuator does not exist.
      //   PERMISSION_DENIED if access is denied for the actuator.
      //   UNAUTHENTICATED if no credentials provided or credentials has expired
      //   UNAVAILABLE if there is no provider currently providing the actuator
      //   DATA_LOSS is there is a internal TransmissionFailure
      //   INVALID_ARGUMENT
      //     - if the provided path is not an actuator.
      //     - if the data type used in the request does not match
      //       the data type of the addressed signal
      //     - if the requested value is not accepted,
      //       e.g. if sending an unsupported enum value
      //     - if the provided value is out of the min/max range specified
      //
      virtual void Actuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest* request, ::kuksa::val::v2::ActuateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Actuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest* request, ::kuksa::val::v2::ActuateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Actuate a single actuator in a gRPC stream -> Use for low latency and high throughput
      //
      // Returns (GRPC error code):
      //   NOT_FOUND if the actuator does not exist.
      //   PERMISSION_DENIED if access is denied for the actuator.
      //   UNAUTHENTICATED if no credentials provided or credentials has expired
      //   UNAVAILABLE if there is no provider currently providing the actuator
      //   DATA_LOSS is there is a internal TransmissionFailure
      //   INVALID_ARGUMENT
      //     - if the provided path is not an actuator.
      //     - if the data type used in the request does not match
      //       the data type of the addressed signal
      //     - if the requested value is not accepted,
      //       e.g. if sending an unsupported enum value
      //     - if the provided value is out of the min/max range specified
      //
      virtual void ActuateStream(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::ClientWriteReactor< ::kuksa::val::v2::ActuateRequest>* reactor) = 0;
      // Actuate simultaneously multiple actuators.
      // If any error occurs, the entire operation will be aborted
      // and no single actuator value will be forwarded to the provider.
      //
      // Returns (GRPC error code):
      //   NOT_FOUND if any of the actuators are non-existant.
      //   PERMISSION_DENIED if access is denied for any of the actuators.
      //   UNAUTHENTICATED if no credentials provided or credentials has expired
      //   UNAVAILABLE if there is no provider currently providing an actuator
      //   DATA_LOSS is there is a internal TransmissionFailure
      //   INVALID_ARGUMENT
      //     - if any of the provided path is not an actuator.
      //     - if the data type used in the request does not match
      //       the data type of the addressed signal
      //     - if the requested value is not accepted,
      //       e.g. if sending an unsupported enum value
      //     - if any of the provided actuators values are out of the min/max range specified
      //
      virtual void BatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest* request, ::kuksa::val::v2::BatchActuateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest* request, ::kuksa::val::v2::BatchActuateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List metadata of signals matching the request.
      //
      // Returns (GRPC error code):
      //   NOT_FOUND if the specified root branch does not exist.
      //   UNAUTHENTICATED if no credentials provided or credentials has expired
      //   INVALID_ARGUMENT if the provided path or wildcard is wrong.
      //
      virtual void ListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest* request, ::kuksa::val::v2::ListMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest* request, ::kuksa::val::v2::ListMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Publish a signal value. Used for low frequency signals (e.g. attributes).
      //
      // Returns (GRPC error code):
      //   NOT_FOUND if any of the signals are non-existant.
      //   PERMISSION_DENIED
      //     - if access is denied for any of the signals.
      //   UNAUTHENTICATED if no credentials provided or credentials has expired
      //   INVALID_ARGUMENT
      //     - if the data type used in the request does not match
      //       the data type of the addressed signal
      //     - if the published value is not accepted,
      //       e.g. if sending an unsupported enum value
      //     - if the published value is out of the min/max range specified
      //
      virtual void PublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest* request, ::kuksa::val::v2::PublishValueResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest* request, ::kuksa::val::v2::PublishValueResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Open a stream used to provide actuation and/or publishing values using
      // a streaming interface. Used to provide actuators and to enable high frequency
      // updates of values.
      //
      // The open stream is used for request / response type communication between the
      // provider and server (where the initiator of a request can vary).
      //
      // Errors:
      //  - Provider sends ProvideActuationRequest -> Databroker returns ProvideActuationResponse.
      //    Possible gRPC error codes:
      //    - NOT_FOUND if any of the signals do not exist.
      //    - PERMISSION_DENIED if access is denied for any of the signals.
      //    - UNAUTHENTICATED if no credentials are provided or if they have expired.
      //    - ALREADY_EXISTS if a provider already claimed ownership of an actuator.
      //
      //  - Provider sends PublishValuesRequest -> Databroker returns PublishValuesResponse
      //    upon error, and nothing upon success. Errors are returned as messages in the
      //    stream response with signal id `map<int32, Error> status = 2;` (permissive case).
      //    Possible error codes:
      //    - NOT_FOUND if a signal does not exist.
      //    - PERMISSION_DENIED if access is denied for a signal.
      //    - INVALID_ARGUMENT if:
      //      - The data type used in the request does not match the signal's data type.
      //      - The published value is unsupported (e.g., sending an invalid enum value).
      //      - The published value is out of the specified min/max range.
      //
      //  - Databroker sends BatchActuateStreamRequest -> Provider must return
      //    BatchActuateStreamResponse for each requested signal to indicate acceptance or rejection.
      //    It is up to the provider to decide if the stream shall be closed. The databroker
      //    will not react to the received error message.
      //
      //  - Provider sends ProvideSignalRequest -> Databroker returns ProvideSignalResponse.
      //    Possible gRPC error codes:
      //    - NOT_FOUND if any signals do not exist.
      //    - PERMISSION_DENIED if access is denied for any of the signals.
      //    - UNAUTHENTICATED if no credentials are provided or if they have expired.
      //    - ALREADY_EXISTS if a provider has already claimed ownership of any signal.
      //
      virtual void OpenProviderStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::kuksa::val::v2::OpenProviderStreamRequest,::kuksa::val::v2::OpenProviderStreamResponse>* reactor) = 0;
      // Get server information
      virtual void GetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest* request, ::kuksa::val::v2::GetServerInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest* request, ::kuksa::val::v2::GetServerInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValueResponse>* AsyncGetValueRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValueResponse>* PrepareAsyncGetValueRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValuesResponse>* AsyncGetValuesRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetValuesResponse>* PrepareAsyncGetValuesRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::kuksa::val::v2::SubscribeResponse>* SubscribeRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeResponse>* AsyncSubscribeRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeResponse>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::kuksa::val::v2::SubscribeByIdResponse>* SubscribeByIdRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeByIdResponse>* AsyncSubscribeByIdRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::kuksa::val::v2::SubscribeByIdResponse>* PrepareAsyncSubscribeByIdRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ActuateResponse>* AsyncActuateRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ActuateResponse>* PrepareAsyncActuateRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::kuksa::val::v2::ActuateRequest>* ActuateStreamRaw(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::kuksa::val::v2::ActuateRequest>* AsyncActuateStreamRaw(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::kuksa::val::v2::ActuateRequest>* PrepareAsyncActuateStreamRaw(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::BatchActuateResponse>* AsyncBatchActuateRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::BatchActuateResponse>* PrepareAsyncBatchActuateRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ListMetadataResponse>* AsyncListMetadataRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::ListMetadataResponse>* PrepareAsyncListMetadataRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::PublishValueResponse>* AsyncPublishValueRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::PublishValueResponse>* PrepareAsyncPublishValueRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>* OpenProviderStreamRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>* AsyncOpenProviderStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>* PrepareAsyncOpenProviderStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetServerInfoResponse>* AsyncGetServerInfoRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::kuksa::val::v2::GetServerInfoResponse>* PrepareAsyncGetServerInfoRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::kuksa::val::v2::GetValueResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValueResponse>> AsyncGetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValueResponse>>(AsyncGetValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValueResponse>> PrepareAsyncGetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValueResponse>>(PrepareAsyncGetValueRaw(context, request, cq));
    }
    ::grpc::Status GetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::kuksa::val::v2::GetValuesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValuesResponse>> AsyncGetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValuesResponse>>(AsyncGetValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValuesResponse>> PrepareAsyncGetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValuesResponse>>(PrepareAsyncGetValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::kuksa::val::v2::SubscribeResponse>> Subscribe(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::kuksa::val::v2::SubscribeResponse>>(SubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeResponse>> AsyncSubscribe(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeResponse>>(AsyncSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeResponse>> PrepareAsyncSubscribe(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeResponse>>(PrepareAsyncSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::kuksa::val::v2::SubscribeByIdResponse>> SubscribeById(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::kuksa::val::v2::SubscribeByIdResponse>>(SubscribeByIdRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeByIdResponse>> AsyncSubscribeById(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeByIdResponse>>(AsyncSubscribeByIdRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeByIdResponse>> PrepareAsyncSubscribeById(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeByIdResponse>>(PrepareAsyncSubscribeByIdRaw(context, request, cq));
    }
    ::grpc::Status Actuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::kuksa::val::v2::ActuateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ActuateResponse>> AsyncActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ActuateResponse>>(AsyncActuateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ActuateResponse>> PrepareAsyncActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ActuateResponse>>(PrepareAsyncActuateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::kuksa::val::v2::ActuateRequest>> ActuateStream(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::kuksa::val::v2::ActuateRequest>>(ActuateStreamRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::kuksa::val::v2::ActuateRequest>> AsyncActuateStream(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::kuksa::val::v2::ActuateRequest>>(AsyncActuateStreamRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::kuksa::val::v2::ActuateRequest>> PrepareAsyncActuateStream(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::kuksa::val::v2::ActuateRequest>>(PrepareAsyncActuateStreamRaw(context, response, cq));
    }
    ::grpc::Status BatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::kuksa::val::v2::BatchActuateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::BatchActuateResponse>> AsyncBatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::BatchActuateResponse>>(AsyncBatchActuateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::BatchActuateResponse>> PrepareAsyncBatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::BatchActuateResponse>>(PrepareAsyncBatchActuateRaw(context, request, cq));
    }
    ::grpc::Status ListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::kuksa::val::v2::ListMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ListMetadataResponse>> AsyncListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ListMetadataResponse>>(AsyncListMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ListMetadataResponse>> PrepareAsyncListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ListMetadataResponse>>(PrepareAsyncListMetadataRaw(context, request, cq));
    }
    ::grpc::Status PublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::kuksa::val::v2::PublishValueResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::PublishValueResponse>> AsyncPublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::PublishValueResponse>>(AsyncPublishValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::PublishValueResponse>> PrepareAsyncPublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::PublishValueResponse>>(PrepareAsyncPublishValueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>> OpenProviderStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>>(OpenProviderStreamRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>> AsyncOpenProviderStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>>(AsyncOpenProviderStreamRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>> PrepareAsyncOpenProviderStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>>(PrepareAsyncOpenProviderStreamRaw(context, cq));
    }
    ::grpc::Status GetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::kuksa::val::v2::GetServerInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetServerInfoResponse>> AsyncGetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetServerInfoResponse>>(AsyncGetServerInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetServerInfoResponse>> PrepareAsyncGetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetServerInfoResponse>>(PrepareAsyncGetServerInfoRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest* request, ::kuksa::val::v2::GetValueResponse* response, std::function<void(::grpc::Status)>) override;
      void GetValue(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest* request, ::kuksa::val::v2::GetValueResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest* request, ::kuksa::val::v2::GetValuesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetValues(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest* request, ::kuksa::val::v2::GetValuesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Subscribe(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest* request, ::grpc::ClientReadReactor< ::kuksa::val::v2::SubscribeResponse>* reactor) override;
      void SubscribeById(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest* request, ::grpc::ClientReadReactor< ::kuksa::val::v2::SubscribeByIdResponse>* reactor) override;
      void Actuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest* request, ::kuksa::val::v2::ActuateResponse* response, std::function<void(::grpc::Status)>) override;
      void Actuate(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest* request, ::kuksa::val::v2::ActuateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ActuateStream(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::ClientWriteReactor< ::kuksa::val::v2::ActuateRequest>* reactor) override;
      void BatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest* request, ::kuksa::val::v2::BatchActuateResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchActuate(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest* request, ::kuksa::val::v2::BatchActuateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest* request, ::kuksa::val::v2::ListMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      void ListMetadata(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest* request, ::kuksa::val::v2::ListMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest* request, ::kuksa::val::v2::PublishValueResponse* response, std::function<void(::grpc::Status)>) override;
      void PublishValue(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest* request, ::kuksa::val::v2::PublishValueResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void OpenProviderStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::kuksa::val::v2::OpenProviderStreamRequest,::kuksa::val::v2::OpenProviderStreamResponse>* reactor) override;
      void GetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest* request, ::kuksa::val::v2::GetServerInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetServerInfo(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest* request, ::kuksa::val::v2::GetServerInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValueResponse>* AsyncGetValueRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValueResponse>* PrepareAsyncGetValueRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValueRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValuesResponse>* AsyncGetValuesRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetValuesResponse>* PrepareAsyncGetValuesRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::kuksa::val::v2::SubscribeResponse>* SubscribeRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeResponse>* AsyncSubscribeRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeResponse>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::kuksa::val::v2::SubscribeByIdResponse>* SubscribeByIdRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request) override;
    ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeByIdResponse>* AsyncSubscribeByIdRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::kuksa::val::v2::SubscribeByIdResponse>* PrepareAsyncSubscribeByIdRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::SubscribeByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ActuateResponse>* AsyncActuateRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ActuateResponse>* PrepareAsyncActuateRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::ActuateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::kuksa::val::v2::ActuateRequest>* ActuateStreamRaw(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response) override;
    ::grpc::ClientAsyncWriter< ::kuksa::val::v2::ActuateRequest>* AsyncActuateStreamRaw(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::kuksa::val::v2::ActuateRequest>* PrepareAsyncActuateStreamRaw(::grpc::ClientContext* context, ::kuksa::val::v2::ActuateResponse* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::BatchActuateResponse>* AsyncBatchActuateRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::BatchActuateResponse>* PrepareAsyncBatchActuateRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::BatchActuateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ListMetadataResponse>* AsyncListMetadataRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::ListMetadataResponse>* PrepareAsyncListMetadataRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::ListMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::PublishValueResponse>* AsyncPublishValueRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::PublishValueResponse>* PrepareAsyncPublishValueRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::PublishValueRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>* OpenProviderStreamRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>* AsyncOpenProviderStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>* PrepareAsyncOpenProviderStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetServerInfoResponse>* AsyncGetServerInfoRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::kuksa::val::v2::GetServerInfoResponse>* PrepareAsyncGetServerInfoRaw(::grpc::ClientContext* context, const ::kuksa::val::v2::GetServerInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetValue_;
    const ::grpc::internal::RpcMethod rpcmethod_GetValues_;
    const ::grpc::internal::RpcMethod rpcmethod_Subscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeById_;
    const ::grpc::internal::RpcMethod rpcmethod_Actuate_;
    const ::grpc::internal::RpcMethod rpcmethod_ActuateStream_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchActuate_;
    const ::grpc::internal::RpcMethod rpcmethod_ListMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_PublishValue_;
    const ::grpc::internal::RpcMethod rpcmethod_OpenProviderStream_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServerInfo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Get the latest value of a signal
    // If the signal exist but does not have a valid value
    // a DataPoint where value is None shall be returned.
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if the requested signal doesn't exist
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   PERMISSION_DENIED if access is denied
    //   INVALID_ARGUMENT if the request is empty or provided path is too long
    //     - MAX_REQUEST_PATH_LENGTH: usize = 1000;
    //
    virtual ::grpc::Status GetValue(::grpc::ServerContext* context, const ::kuksa::val::v2::GetValueRequest* request, ::kuksa::val::v2::GetValueResponse* response);
    // Get the latest values of a set of signals.
    // The returned list of data points has the same order as the list of the request.
    // If a requested signal has no value a DataPoint where value is None will be returned.
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the requested signals doesn't exist.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   PERMISSION_DENIED if access is denied for any of the requested signals.
    //   INVALID_ARGUMENT if the request is empty or provided path is too long
    //     - MAX_REQUEST_PATH_LENGTH: usize = 1000;
    //
    virtual ::grpc::Status GetValues(::grpc::ServerContext* context, const ::kuksa::val::v2::GetValuesRequest* request, ::kuksa::val::v2::GetValuesResponse* response);
    // Subscribe to a set of signals using string path parameters
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the signals are non-existant.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   PERMISSION_DENIED if access is denied for any of the signals.
    //   INVALID_ARGUMENT
    //     - if the request is empty or provided path is too long
    //       MAX_REQUEST_PATH_LENGTH: usize = 1000;
    //     - if buffer_size exceeds the maximum permitted
    //       MAX_BUFFER_SIZE: usize = 1000;
    //
    // When subscribing, Databroker shall immediately return the value for all
    // subscribed entries.
    // If a value isn't available when subscribing to a it, it should return None
    //
    // If a subscriber is slow to consume signals, messages will be buffered up
    // to the specified buffer_size before the oldest messages are dropped.
    //
    virtual ::grpc::Status Subscribe(::grpc::ServerContext* context, const ::kuksa::val::v2::SubscribeRequest* request, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeResponse>* writer);
    // Subscribe to a set of signals using i32 id parameters
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the signals are non-existant.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   PERMISSION_DENIED if access is denied for any of the signals.
    //   INVALID_ARGUMENT
    //     - if the request is empty or provided path is too long
    //       MAX_REQUEST_PATH_LENGTH: usize = 1000;
    //     - if buffer_size exceeds the maximum permitted
    //       MAX_BUFFER_SIZE: usize = 1000;
    //
    // When subscribing, Databroker shall immediately return the value for all
    // subscribed entries.
    // If a value isn't available when subscribing to a it, it should return None
    //
    // If a subscriber is slow to consume signals, messages will be buffered up
    // to the specified buffer_size before the oldest messages are dropped.
    //
    virtual ::grpc::Status SubscribeById(::grpc::ServerContext* context, const ::kuksa::val::v2::SubscribeByIdRequest* request, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeByIdResponse>* writer);
    // Actuate a single actuator
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if the actuator does not exist.
    //   PERMISSION_DENIED if access is denied for the actuator.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   UNAVAILABLE if there is no provider currently providing the actuator
    //   DATA_LOSS is there is a internal TransmissionFailure
    //   INVALID_ARGUMENT
    //     - if the provided path is not an actuator.
    //     - if the data type used in the request does not match
    //       the data type of the addressed signal
    //     - if the requested value is not accepted,
    //       e.g. if sending an unsupported enum value
    //     - if the provided value is out of the min/max range specified
    //
    virtual ::grpc::Status Actuate(::grpc::ServerContext* context, const ::kuksa::val::v2::ActuateRequest* request, ::kuksa::val::v2::ActuateResponse* response);
    // Actuate a single actuator in a gRPC stream -> Use for low latency and high throughput
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if the actuator does not exist.
    //   PERMISSION_DENIED if access is denied for the actuator.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   UNAVAILABLE if there is no provider currently providing the actuator
    //   DATA_LOSS is there is a internal TransmissionFailure
    //   INVALID_ARGUMENT
    //     - if the provided path is not an actuator.
    //     - if the data type used in the request does not match
    //       the data type of the addressed signal
    //     - if the requested value is not accepted,
    //       e.g. if sending an unsupported enum value
    //     - if the provided value is out of the min/max range specified
    //
    virtual ::grpc::Status ActuateStream(::grpc::ServerContext* context, ::grpc::ServerReader< ::kuksa::val::v2::ActuateRequest>* reader, ::kuksa::val::v2::ActuateResponse* response);
    // Actuate simultaneously multiple actuators.
    // If any error occurs, the entire operation will be aborted
    // and no single actuator value will be forwarded to the provider.
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the actuators are non-existant.
    //   PERMISSION_DENIED if access is denied for any of the actuators.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   UNAVAILABLE if there is no provider currently providing an actuator
    //   DATA_LOSS is there is a internal TransmissionFailure
    //   INVALID_ARGUMENT
    //     - if any of the provided path is not an actuator.
    //     - if the data type used in the request does not match
    //       the data type of the addressed signal
    //     - if the requested value is not accepted,
    //       e.g. if sending an unsupported enum value
    //     - if any of the provided actuators values are out of the min/max range specified
    //
    virtual ::grpc::Status BatchActuate(::grpc::ServerContext* context, const ::kuksa::val::v2::BatchActuateRequest* request, ::kuksa::val::v2::BatchActuateResponse* response);
    // List metadata of signals matching the request.
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if the specified root branch does not exist.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   INVALID_ARGUMENT if the provided path or wildcard is wrong.
    //
    virtual ::grpc::Status ListMetadata(::grpc::ServerContext* context, const ::kuksa::val::v2::ListMetadataRequest* request, ::kuksa::val::v2::ListMetadataResponse* response);
    // Publish a signal value. Used for low frequency signals (e.g. attributes).
    //
    // Returns (GRPC error code):
    //   NOT_FOUND if any of the signals are non-existant.
    //   PERMISSION_DENIED
    //     - if access is denied for any of the signals.
    //   UNAUTHENTICATED if no credentials provided or credentials has expired
    //   INVALID_ARGUMENT
    //     - if the data type used in the request does not match
    //       the data type of the addressed signal
    //     - if the published value is not accepted,
    //       e.g. if sending an unsupported enum value
    //     - if the published value is out of the min/max range specified
    //
    virtual ::grpc::Status PublishValue(::grpc::ServerContext* context, const ::kuksa::val::v2::PublishValueRequest* request, ::kuksa::val::v2::PublishValueResponse* response);
    // Open a stream used to provide actuation and/or publishing values using
    // a streaming interface. Used to provide actuators and to enable high frequency
    // updates of values.
    //
    // The open stream is used for request / response type communication between the
    // provider and server (where the initiator of a request can vary).
    //
    // Errors:
    //  - Provider sends ProvideActuationRequest -> Databroker returns ProvideActuationResponse.
    //    Possible gRPC error codes:
    //    - NOT_FOUND if any of the signals do not exist.
    //    - PERMISSION_DENIED if access is denied for any of the signals.
    //    - UNAUTHENTICATED if no credentials are provided or if they have expired.
    //    - ALREADY_EXISTS if a provider already claimed ownership of an actuator.
    //
    //  - Provider sends PublishValuesRequest -> Databroker returns PublishValuesResponse
    //    upon error, and nothing upon success. Errors are returned as messages in the
    //    stream response with signal id `map<int32, Error> status = 2;` (permissive case).
    //    Possible error codes:
    //    - NOT_FOUND if a signal does not exist.
    //    - PERMISSION_DENIED if access is denied for a signal.
    //    - INVALID_ARGUMENT if:
    //      - The data type used in the request does not match the signal's data type.
    //      - The published value is unsupported (e.g., sending an invalid enum value).
    //      - The published value is out of the specified min/max range.
    //
    //  - Databroker sends BatchActuateStreamRequest -> Provider must return
    //    BatchActuateStreamResponse for each requested signal to indicate acceptance or rejection.
    //    It is up to the provider to decide if the stream shall be closed. The databroker
    //    will not react to the received error message.
    //
    //  - Provider sends ProvideSignalRequest -> Databroker returns ProvideSignalResponse.
    //    Possible gRPC error codes:
    //    - NOT_FOUND if any signals do not exist.
    //    - PERMISSION_DENIED if access is denied for any of the signals.
    //    - UNAUTHENTICATED if no credentials are provided or if they have expired.
    //    - ALREADY_EXISTS if a provider has already claimed ownership of any signal.
    //
    virtual ::grpc::Status OpenProviderStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::kuksa::val::v2::OpenProviderStreamResponse, ::kuksa::val::v2::OpenProviderStreamRequest>* stream);
    // Get server information
    virtual ::grpc::Status GetServerInfo(::grpc::ServerContext* context, const ::kuksa::val::v2::GetServerInfoRequest* request, ::kuksa::val::v2::GetServerInfoResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetValue() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValueRequest* /*request*/, ::kuksa::val::v2::GetValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetValue(::grpc::ServerContext* context, ::kuksa::val::v2::GetValueRequest* request, ::grpc::ServerAsyncResponseWriter< ::kuksa::val::v2::GetValueResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetValues() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValues(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValuesRequest* /*request*/, ::kuksa::val::v2::GetValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetValues(::grpc::ServerContext* context, ::kuksa::val::v2::GetValuesRequest* request, ::grpc::ServerAsyncResponseWriter< ::kuksa::val::v2::GetValuesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Subscribe() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::kuksa::val::v2::SubscribeRequest* request, ::grpc::ServerAsyncWriter< ::kuksa::val::v2::SubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeById() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SubscribeById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeById(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeByIdRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeByIdResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeById(::grpc::ServerContext* context, ::kuksa::val::v2::SubscribeByIdRequest* request, ::grpc::ServerAsyncWriter< ::kuksa::val::v2::SubscribeByIdResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Actuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Actuate() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Actuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Actuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ActuateRequest* /*request*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActuate(::grpc::ServerContext* context, ::kuksa::val::v2::ActuateRequest* request, ::grpc::ServerAsyncResponseWriter< ::kuksa::val::v2::ActuateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ActuateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ActuateStream() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ActuateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActuateStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::kuksa::val::v2::ActuateRequest>* /*reader*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActuateStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::kuksa::val::v2::ActuateResponse, ::kuksa::val::v2::ActuateRequest>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(5, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchActuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchActuate() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_BatchActuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchActuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::BatchActuateRequest* /*request*/, ::kuksa::val::v2::BatchActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchActuate(::grpc::ServerContext* context, ::kuksa::val::v2::BatchActuateRequest* request, ::grpc::ServerAsyncResponseWriter< ::kuksa::val::v2::BatchActuateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListMetadata() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ListMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMetadata(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ListMetadataRequest* /*request*/, ::kuksa::val::v2::ListMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMetadata(::grpc::ServerContext* context, ::kuksa::val::v2::ListMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::kuksa::val::v2::ListMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PublishValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PublishValue() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_PublishValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::PublishValueRequest* /*request*/, ::kuksa::val::v2::PublishValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishValue(::grpc::ServerContext* context, ::kuksa::val::v2::PublishValueRequest* request, ::grpc::ServerAsyncResponseWriter< ::kuksa::val::v2::PublishValueResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OpenProviderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OpenProviderStream() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_OpenProviderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenProviderStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::kuksa::val::v2::OpenProviderStreamResponse, ::kuksa::val::v2::OpenProviderStreamRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenProviderStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::kuksa::val::v2::OpenProviderStreamResponse, ::kuksa::val::v2::OpenProviderStreamRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(9, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServerInfo() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetServerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerInfo(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetServerInfoRequest* /*request*/, ::kuksa::val::v2::GetServerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServerInfo(::grpc::ServerContext* context, ::kuksa::val::v2::GetServerInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::kuksa::val::v2::GetServerInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetValue<WithAsyncMethod_GetValues<WithAsyncMethod_Subscribe<WithAsyncMethod_SubscribeById<WithAsyncMethod_Actuate<WithAsyncMethod_ActuateStream<WithAsyncMethod_BatchActuate<WithAsyncMethod_ListMetadata<WithAsyncMethod_PublishValue<WithAsyncMethod_OpenProviderStream<WithAsyncMethod_GetServerInfo<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetValue() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::GetValueRequest, ::kuksa::val::v2::GetValueResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::kuksa::val::v2::GetValueRequest* request, ::kuksa::val::v2::GetValueResponse* response) { return this->GetValue(context, request, response); }));}
    void SetMessageAllocatorFor_GetValue(
        ::grpc::MessageAllocator< ::kuksa::val::v2::GetValueRequest, ::kuksa::val::v2::GetValueResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::GetValueRequest, ::kuksa::val::v2::GetValueResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValueRequest* /*request*/, ::kuksa::val::v2::GetValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetValue(
      ::grpc::CallbackServerContext* /*context*/, const ::kuksa::val::v2::GetValueRequest* /*request*/, ::kuksa::val::v2::GetValueResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetValues() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::GetValuesRequest, ::kuksa::val::v2::GetValuesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::kuksa::val::v2::GetValuesRequest* request, ::kuksa::val::v2::GetValuesResponse* response) { return this->GetValues(context, request, response); }));}
    void SetMessageAllocatorFor_GetValues(
        ::grpc::MessageAllocator< ::kuksa::val::v2::GetValuesRequest, ::kuksa::val::v2::GetValuesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::GetValuesRequest, ::kuksa::val::v2::GetValuesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValues(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValuesRequest* /*request*/, ::kuksa::val::v2::GetValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetValues(
      ::grpc::CallbackServerContext* /*context*/, const ::kuksa::val::v2::GetValuesRequest* /*request*/, ::kuksa::val::v2::GetValuesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::kuksa::val::v2::SubscribeRequest, ::kuksa::val::v2::SubscribeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::kuksa::val::v2::SubscribeRequest* request) { return this->Subscribe(context, request); }));
    }
    ~WithCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::kuksa::val::v2::SubscribeResponse>* Subscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::kuksa::val::v2::SubscribeRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeById() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::kuksa::val::v2::SubscribeByIdRequest, ::kuksa::val::v2::SubscribeByIdResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::kuksa::val::v2::SubscribeByIdRequest* request) { return this->SubscribeById(context, request); }));
    }
    ~WithCallbackMethod_SubscribeById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeById(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeByIdRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeByIdResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::kuksa::val::v2::SubscribeByIdResponse>* SubscribeById(
      ::grpc::CallbackServerContext* /*context*/, const ::kuksa::val::v2::SubscribeByIdRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Actuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Actuate() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::ActuateRequest, ::kuksa::val::v2::ActuateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::kuksa::val::v2::ActuateRequest* request, ::kuksa::val::v2::ActuateResponse* response) { return this->Actuate(context, request, response); }));}
    void SetMessageAllocatorFor_Actuate(
        ::grpc::MessageAllocator< ::kuksa::val::v2::ActuateRequest, ::kuksa::val::v2::ActuateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::ActuateRequest, ::kuksa::val::v2::ActuateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Actuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Actuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ActuateRequest* /*request*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Actuate(
      ::grpc::CallbackServerContext* /*context*/, const ::kuksa::val::v2::ActuateRequest* /*request*/, ::kuksa::val::v2::ActuateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ActuateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ActuateStream() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackClientStreamingHandler< ::kuksa::val::v2::ActuateRequest, ::kuksa::val::v2::ActuateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, ::kuksa::val::v2::ActuateResponse* response) { return this->ActuateStream(context, response); }));
    }
    ~WithCallbackMethod_ActuateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActuateStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::kuksa::val::v2::ActuateRequest>* /*reader*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::kuksa::val::v2::ActuateRequest>* ActuateStream(
      ::grpc::CallbackServerContext* /*context*/, ::kuksa::val::v2::ActuateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchActuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchActuate() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::BatchActuateRequest, ::kuksa::val::v2::BatchActuateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::kuksa::val::v2::BatchActuateRequest* request, ::kuksa::val::v2::BatchActuateResponse* response) { return this->BatchActuate(context, request, response); }));}
    void SetMessageAllocatorFor_BatchActuate(
        ::grpc::MessageAllocator< ::kuksa::val::v2::BatchActuateRequest, ::kuksa::val::v2::BatchActuateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::BatchActuateRequest, ::kuksa::val::v2::BatchActuateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchActuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchActuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::BatchActuateRequest* /*request*/, ::kuksa::val::v2::BatchActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchActuate(
      ::grpc::CallbackServerContext* /*context*/, const ::kuksa::val::v2::BatchActuateRequest* /*request*/, ::kuksa::val::v2::BatchActuateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListMetadata() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::ListMetadataRequest, ::kuksa::val::v2::ListMetadataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::kuksa::val::v2::ListMetadataRequest* request, ::kuksa::val::v2::ListMetadataResponse* response) { return this->ListMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_ListMetadata(
        ::grpc::MessageAllocator< ::kuksa::val::v2::ListMetadataRequest, ::kuksa::val::v2::ListMetadataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::ListMetadataRequest, ::kuksa::val::v2::ListMetadataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMetadata(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ListMetadataRequest* /*request*/, ::kuksa::val::v2::ListMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::kuksa::val::v2::ListMetadataRequest* /*request*/, ::kuksa::val::v2::ListMetadataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PublishValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PublishValue() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::PublishValueRequest, ::kuksa::val::v2::PublishValueResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::kuksa::val::v2::PublishValueRequest* request, ::kuksa::val::v2::PublishValueResponse* response) { return this->PublishValue(context, request, response); }));}
    void SetMessageAllocatorFor_PublishValue(
        ::grpc::MessageAllocator< ::kuksa::val::v2::PublishValueRequest, ::kuksa::val::v2::PublishValueResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::PublishValueRequest, ::kuksa::val::v2::PublishValueResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PublishValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::PublishValueRequest* /*request*/, ::kuksa::val::v2::PublishValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PublishValue(
      ::grpc::CallbackServerContext* /*context*/, const ::kuksa::val::v2::PublishValueRequest* /*request*/, ::kuksa::val::v2::PublishValueResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_OpenProviderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_OpenProviderStream() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackBidiHandler< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->OpenProviderStream(context); }));
    }
    ~WithCallbackMethod_OpenProviderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenProviderStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::kuksa::val::v2::OpenProviderStreamResponse, ::kuksa::val::v2::OpenProviderStreamRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::kuksa::val::v2::OpenProviderStreamRequest, ::kuksa::val::v2::OpenProviderStreamResponse>* OpenProviderStream(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetServerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetServerInfo() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::GetServerInfoRequest, ::kuksa::val::v2::GetServerInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::kuksa::val::v2::GetServerInfoRequest* request, ::kuksa::val::v2::GetServerInfoResponse* response) { return this->GetServerInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetServerInfo(
        ::grpc::MessageAllocator< ::kuksa::val::v2::GetServerInfoRequest, ::kuksa::val::v2::GetServerInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::kuksa::val::v2::GetServerInfoRequest, ::kuksa::val::v2::GetServerInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetServerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerInfo(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetServerInfoRequest* /*request*/, ::kuksa::val::v2::GetServerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServerInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::kuksa::val::v2::GetServerInfoRequest* /*request*/, ::kuksa::val::v2::GetServerInfoResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetValue<WithCallbackMethod_GetValues<WithCallbackMethod_Subscribe<WithCallbackMethod_SubscribeById<WithCallbackMethod_Actuate<WithCallbackMethod_ActuateStream<WithCallbackMethod_BatchActuate<WithCallbackMethod_ListMetadata<WithCallbackMethod_PublishValue<WithCallbackMethod_OpenProviderStream<WithCallbackMethod_GetServerInfo<Service > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetValue() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValueRequest* /*request*/, ::kuksa::val::v2::GetValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetValues() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValues(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValuesRequest* /*request*/, ::kuksa::val::v2::GetValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Subscribe() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeById() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SubscribeById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeById(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeByIdRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeByIdResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Actuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Actuate() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Actuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Actuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ActuateRequest* /*request*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ActuateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ActuateStream() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ActuateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActuateStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::kuksa::val::v2::ActuateRequest>* /*reader*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchActuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchActuate() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_BatchActuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchActuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::BatchActuateRequest* /*request*/, ::kuksa::val::v2::BatchActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListMetadata() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ListMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMetadata(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ListMetadataRequest* /*request*/, ::kuksa::val::v2::ListMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PublishValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PublishValue() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_PublishValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::PublishValueRequest* /*request*/, ::kuksa::val::v2::PublishValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OpenProviderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OpenProviderStream() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_OpenProviderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenProviderStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::kuksa::val::v2::OpenProviderStreamResponse, ::kuksa::val::v2::OpenProviderStreamRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServerInfo() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetServerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerInfo(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetServerInfoRequest* /*request*/, ::kuksa::val::v2::GetServerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetValue() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValueRequest* /*request*/, ::kuksa::val::v2::GetValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetValue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetValues() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValues(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValuesRequest* /*request*/, ::kuksa::val::v2::GetValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetValues(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Subscribe() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeById() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SubscribeById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeById(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeByIdRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeByIdResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeById(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Actuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Actuate() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Actuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Actuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ActuateRequest* /*request*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActuate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ActuateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ActuateStream() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ActuateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActuateStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::kuksa::val::v2::ActuateRequest>* /*reader*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActuateStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(5, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchActuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchActuate() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_BatchActuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchActuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::BatchActuateRequest* /*request*/, ::kuksa::val::v2::BatchActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchActuate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListMetadata() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ListMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMetadata(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ListMetadataRequest* /*request*/, ::kuksa::val::v2::ListMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PublishValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PublishValue() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_PublishValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::PublishValueRequest* /*request*/, ::kuksa::val::v2::PublishValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishValue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OpenProviderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OpenProviderStream() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_OpenProviderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenProviderStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::kuksa::val::v2::OpenProviderStreamResponse, ::kuksa::val::v2::OpenProviderStreamRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenProviderStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(9, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServerInfo() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetServerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerInfo(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetServerInfoRequest* /*request*/, ::kuksa::val::v2::GetServerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServerInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetValue() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetValue(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValueRequest* /*request*/, ::kuksa::val::v2::GetValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetValue(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetValues() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetValues(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetValues(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValuesRequest* /*request*/, ::kuksa::val::v2::GetValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetValues(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->Subscribe(context, request); }));
    }
    ~WithRawCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Subscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeById() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeById(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeById(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeByIdRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeByIdResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeById(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Actuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Actuate() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Actuate(context, request, response); }));
    }
    ~WithRawCallbackMethod_Actuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Actuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ActuateRequest* /*request*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Actuate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ActuateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ActuateStream() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->ActuateStream(context, response); }));
    }
    ~WithRawCallbackMethod_ActuateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActuateStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::kuksa::val::v2::ActuateRequest>* /*reader*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* ActuateStream(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchActuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchActuate() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchActuate(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchActuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchActuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::BatchActuateRequest* /*request*/, ::kuksa::val::v2::BatchActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchActuate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListMetadata() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMetadata(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ListMetadataRequest* /*request*/, ::kuksa::val::v2::ListMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PublishValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PublishValue() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PublishValue(context, request, response); }));
    }
    ~WithRawCallbackMethod_PublishValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::PublishValueRequest* /*request*/, ::kuksa::val::v2::PublishValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PublishValue(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_OpenProviderStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_OpenProviderStream() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->OpenProviderStream(context); }));
    }
    ~WithRawCallbackMethod_OpenProviderStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenProviderStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::kuksa::val::v2::OpenProviderStreamResponse, ::kuksa::val::v2::OpenProviderStreamRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* OpenProviderStream(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetServerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetServerInfo() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServerInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetServerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerInfo(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetServerInfoRequest* /*request*/, ::kuksa::val::v2::GetServerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServerInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetValue() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::kuksa::val::v2::GetValueRequest, ::kuksa::val::v2::GetValueResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::kuksa::val::v2::GetValueRequest, ::kuksa::val::v2::GetValueResponse>* streamer) {
                       return this->StreamedGetValue(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValueRequest* /*request*/, ::kuksa::val::v2::GetValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetValue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kuksa::val::v2::GetValueRequest,::kuksa::val::v2::GetValueResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetValues() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::kuksa::val::v2::GetValuesRequest, ::kuksa::val::v2::GetValuesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::kuksa::val::v2::GetValuesRequest, ::kuksa::val::v2::GetValuesResponse>* streamer) {
                       return this->StreamedGetValues(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetValues(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetValuesRequest* /*request*/, ::kuksa::val::v2::GetValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetValues(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kuksa::val::v2::GetValuesRequest,::kuksa::val::v2::GetValuesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Actuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Actuate() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::kuksa::val::v2::ActuateRequest, ::kuksa::val::v2::ActuateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::kuksa::val::v2::ActuateRequest, ::kuksa::val::v2::ActuateResponse>* streamer) {
                       return this->StreamedActuate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Actuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Actuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ActuateRequest* /*request*/, ::kuksa::val::v2::ActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedActuate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kuksa::val::v2::ActuateRequest,::kuksa::val::v2::ActuateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchActuate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchActuate() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::kuksa::val::v2::BatchActuateRequest, ::kuksa::val::v2::BatchActuateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::kuksa::val::v2::BatchActuateRequest, ::kuksa::val::v2::BatchActuateResponse>* streamer) {
                       return this->StreamedBatchActuate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchActuate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchActuate(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::BatchActuateRequest* /*request*/, ::kuksa::val::v2::BatchActuateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchActuate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kuksa::val::v2::BatchActuateRequest,::kuksa::val::v2::BatchActuateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListMetadata() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::kuksa::val::v2::ListMetadataRequest, ::kuksa::val::v2::ListMetadataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::kuksa::val::v2::ListMetadataRequest, ::kuksa::val::v2::ListMetadataResponse>* streamer) {
                       return this->StreamedListMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListMetadata(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::ListMetadataRequest* /*request*/, ::kuksa::val::v2::ListMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kuksa::val::v2::ListMetadataRequest,::kuksa::val::v2::ListMetadataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PublishValue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PublishValue() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::kuksa::val::v2::PublishValueRequest, ::kuksa::val::v2::PublishValueResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::kuksa::val::v2::PublishValueRequest, ::kuksa::val::v2::PublishValueResponse>* streamer) {
                       return this->StreamedPublishValue(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PublishValue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PublishValue(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::PublishValueRequest* /*request*/, ::kuksa::val::v2::PublishValueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPublishValue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kuksa::val::v2::PublishValueRequest,::kuksa::val::v2::PublishValueResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServerInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServerInfo() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::kuksa::val::v2::GetServerInfoRequest, ::kuksa::val::v2::GetServerInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::kuksa::val::v2::GetServerInfoRequest, ::kuksa::val::v2::GetServerInfoResponse>* streamer) {
                       return this->StreamedGetServerInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServerInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServerInfo(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::GetServerInfoRequest* /*request*/, ::kuksa::val::v2::GetServerInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServerInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::kuksa::val::v2::GetServerInfoRequest,::kuksa::val::v2::GetServerInfoResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetValue<WithStreamedUnaryMethod_GetValues<WithStreamedUnaryMethod_Actuate<WithStreamedUnaryMethod_BatchActuate<WithStreamedUnaryMethod_ListMetadata<WithStreamedUnaryMethod_PublishValue<WithStreamedUnaryMethod_GetServerInfo<Service > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Subscribe() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::kuksa::val::v2::SubscribeRequest, ::kuksa::val::v2::SubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::kuksa::val::v2::SubscribeRequest, ::kuksa::val::v2::SubscribeResponse>* streamer) {
                       return this->StreamedSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::kuksa::val::v2::SubscribeRequest,::kuksa::val::v2::SubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeById : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeById() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::kuksa::val::v2::SubscribeByIdRequest, ::kuksa::val::v2::SubscribeByIdResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::kuksa::val::v2::SubscribeByIdRequest, ::kuksa::val::v2::SubscribeByIdResponse>* streamer) {
                       return this->StreamedSubscribeById(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeById() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeById(::grpc::ServerContext* /*context*/, const ::kuksa::val::v2::SubscribeByIdRequest* /*request*/, ::grpc::ServerWriter< ::kuksa::val::v2::SubscribeByIdResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeById(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::kuksa::val::v2::SubscribeByIdRequest,::kuksa::val::v2::SubscribeByIdResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Subscribe<WithSplitStreamingMethod_SubscribeById<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetValue<WithStreamedUnaryMethod_GetValues<WithSplitStreamingMethod_Subscribe<WithSplitStreamingMethod_SubscribeById<WithStreamedUnaryMethod_Actuate<WithStreamedUnaryMethod_BatchActuate<WithStreamedUnaryMethod_ListMetadata<WithStreamedUnaryMethod_PublishValue<WithStreamedUnaryMethod_GetServerInfo<Service > > > > > > > > > StreamedService;
};

}  // namespace v2
}  // namespace val
}  // namespace kuksa


#endif  // GRPC_kuksa_2fval_2fv2_2fval_2eproto__INCLUDED
