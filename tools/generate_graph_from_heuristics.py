#!/usr/bin/env python3
"""
Generate a graph.dot from items using simple heuristics based on ids.
Produces `graph.dot.proposed` and `graph.dot` (identical; you can edit proposed before applying).

Rules implemented:
- Parse front-matter `id:` from markdown items under expectations/, assertions/, evidences/, assumptions/.
- Normalize id core as the part after the first dash: e.g. EXPECT-L0-3 -> L0-3.
- For each id core, build edges:
  - if expect and assert exist: "EXPECT-ID" -> "ASSERT-ID"
  - for each evidence in same core: "EVID-ID" -> "ASSERT-ID"
  - for each assumption in same core: if EXPECT exists then "EXPECT-ID" -> "ASSUMP-ID" else "ASSERT-ID" -> "ASSUMP-ID"

Usage:
  python3 tools/generate_graph_from_heuristics.py --items docs/TSF/tsf_implementation/items --out docs/TSF/tsf_implementation/graph/graph.dot.proposed

This is conservative and only uses id-based matching; it also prints a CSV of proposals for review.
"""

import argparse
from pathlib import Path
import re
import csv


def read_id(path: Path):
    txt = path.read_text(encoding='utf-8')
    m = re.search(r"^id:\s*(.+)$", txt, re.M)
    if m:
        return m.group(1).strip().strip('"').strip("'")
    # fallback: try to infer from filename
    return path.stem


def core_of(idstr: str):
    if '-' in idstr:
        return idstr.split('-',1)[1]
    return idstr


def main():
    p = argparse.ArgumentParser()
    p.add_argument('--items', default='docs/TSF/tsf_implementation/items')
    p.add_argument('--out', default='docs/TSF/tsf_implementation/graph/graph.dot.proposed')
    args = p.parse_args()

    items_dir = Path(args.items)
    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)

    groups = {}  # core -> { 'EXPECT':[], 'ASSERT':[], 'EVID':[], 'ASSUMP':[] }

    for kind in ['expectations','assertions','evidences','assumptions']:
        d = items_dir / kind
        if not d.exists():
            continue
        for md in sorted(d.glob('*.md')):
            idv = read_id(md)
            core = core_of(idv)
            groups.setdefault(core, {'EXPECT':[], 'ASSERT':[], 'EVID':[], 'ASSUMP':[]})
            prefix = idv.split('-',1)[0] if '-' in idv else ''
            # map prefix loosely
            if prefix.upper().startswith('EXPECT') or kind=='expectations':
                groups[core]['EXPECT'].append(idv)
            elif prefix.upper().startswith('ASSERT') or kind=='assertions':
                groups[core]['ASSERT'].append(idv)
            elif prefix.upper().startswith('EVID') or kind=='evidences':
                groups[core]['EVID'].append(idv)
            elif prefix.upper().startswith('ASSUMP') or kind=='assumptions':
                groups[core]['ASSUMP'].append(idv)
            else:
                # fallback by kind
                if kind=='expectations':
                    groups[core]['EXPECT'].append(idv)
                elif kind=='assertions':
                    groups[core]['ASSERT'].append(idv)
                elif kind=='evidences':
                    groups[core]['EVID'].append(idv)
                elif kind=='assumptions':
                    groups[core]['ASSUMP'].append(idv)

    edges = []  # tuples (from,to,reason,score)

    for core,items in sorted(groups.items()):
        expects = items['EXPECT']
        asserts = items['ASSERT']
        evids = items['EVID']
        assumps = items['ASSUMP']

        # pick representative ids if multiple exist (we will link all, but preferentially use first)
        expect = expects[0] if expects else None
        assert_ = asserts[0] if asserts else None

        # EXPECT -> ASSERT
        if expect and assert_:
            edges.append((expect, assert_, 'expect->assert (id core match)', 100))

        # EVID -> ASSERT (user specified EVID.id -> ASSERT.id)
        if assert_:
            for e in evids:
                edges.append((e, assert_, 'evid->assert (id core match)', 90))

        # ASSUMP links: prefer linking EXPECT->ASSUMP (assump supports expect/assert)
        for a in assumps:
            if expect:
                edges.append((expect, a, 'expect->assump (id core match)', 60))
            elif assert_:
                edges.append((assert_, a, 'assert->assump (id core match)', 50))

    # write proposed DOT and CSV
    dot_lines = ['digraph G {', '  // graph generated by tools/generate_graph_from_heuristics.py']
    csv_rows = []
    for frm,to,reason,score in edges:
        dot_lines.append(f'  "{frm}" -> "{to}";')
        csv_rows.append({'from':frm,'to':to,'score':score,'reason':reason})
    dot_lines.append('}')

    proposed = out_path.with_suffix('.proposed') if not str(out_path).endswith('.proposed') else out_path
    proposed.write_text('\n'.join(dot_lines)+'\n', encoding='utf-8')

    # also write a .csv for review
    csv_path = proposed.with_suffix('.proposed.csv')
    with csv_path.open('w', newline='', encoding='utf-8') as fh:
        w = csv.DictWriter(fh, fieldnames=['from','to','score','reason'])
        w.writeheader()
        for r in csv_rows:
            w.writerow(r)

    # Also mirror proposed to graph.dot (overwrite) to allow immediate dry-run application
    graph_dot = proposed.with_suffix('') if str(proposed).endswith('.proposed') else out_path
    graph_dot_path = Path(str(proposed).replace('.proposed',''))
    graph_dot_path.write_text('\n'.join(dot_lines)+'\n', encoding='utf-8')

    print('Wrote proposed graph to', proposed)
    print('Wrote CSV proposals to', csv_path)
    print('Also wrote graph to', graph_dot_path)

if __name__ == '__main__':
    main()
