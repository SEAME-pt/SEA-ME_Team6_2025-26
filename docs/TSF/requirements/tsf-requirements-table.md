# Level 0 (Client) Requirements — PiRacer Warm-Up Project

This document defines the **Level 0 (Client) Requirements** for the PiRacer Warm-Up module.  
Each requirement is written from the client’s perspective, includes measurable acceptance criteria,  
and is testable and traceable to the system architecture and corresponding test cases.  
These requirements establish the scope, priorities, and evaluation criteria for the project.

---

## Table of Contents
1. [Overview](#overview)  
2. [Level 0 Requirements](#level-0-requirements)  
3. [Traceability and Verification](#traceability-and-verification)

---

## Overview

The PiRacer Warm-Up project aims to familiarize students with:
- The **PiRacer robot hardware**, including the Raspberry Pi 5, Hailo AI Hat, DC and servo motors, and built-in display.
- The development of a **simple Qt-based graphical application** running on the PiRacer’s display.
- The use of **Git and GitHub** for collaborative software development.
- The application of **Agile (Scrum)** methodologies for team organization and project management.
- The integration of the **Trustable Software Framework (TSF)** to ensure traceability between requirements, design, and testing.

---

## Level 0 Requirements

| **ID** | **Requirement (Client View)** | **Acceptance Criteria** | **Verification Method**|  **Evidence** |
|:-------|:------------------------------|:------------------------|:------------------------|:------------------|
| **L0-1** | The system architecture shall be defined and documented to describe hardware and software components, including the Expansion Board, Raspberry Pi 5, Hailo AI Hat, DC motors, servo motor, and display interface. |A system architecture diagram or document is present in the repository. | Documentation inspection. | EXPECT-L0-1 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/assembled-car1.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/assembled-car2.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/eletric-scheme.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Validation-of-energy-layout-sprint3.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/Power%20Consumption%20Analysis.md<br>`docs/demos/assembled-car1.jpeg`<br>`docs/demos/assembled-car2.jpeg`<br>`docs/demos/eletric-scheme.png`<br>`docs/demos/Validation-of-energy-layout-sprint3.jpeg`<br>`docs/guides/Power Consumption Analysis.md` |
| **L0-2** | Hardware Assembly: Fully assemble the PiRacer robot, including the Raspberry Pi 5, Hailo AI Hat, DC motors, servo motor, and display interface (first with the old architecture. Then with the new one). | All hardware components are correctly installed and operational. The PiRacer can power on and communicate with the display and motors. | Physical inspection and functional test. | EXPECT-L0-2 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/3d-car.jpg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/3d-car2.jpg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/3d-car3.jpg<br>`docs/demos/3d-car.jpg`<br>`docs/demos/3d-car2.jpg`<br>`docs/demos/3d-car3.jpg` |
| **L0-3** | Software Setup: The system shall successfully boot the Raspberry Pi 5 and load a Linux environment (Trixie, Bookworm and finally AGL) capable of running Qt applications. | The PiRacer boots without system errors, and Qt development tools are accessible from the command line. | System boot demonstration and OS verification. | EXPECT-L0-3 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/AGL_Installation_Guide.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/AGL%20and%20ThreadX%20benefits%20Guide.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/tree/main/src/cluster<br>`docs/guides/AGL_Installation_Guide.md` |
| **L0-4** | Driveable Car with Remote Control/Driveable Car Model (Hardware + Software): The PiRacer shall support remote control functionality to operate the motors (steering and propulsion). | The system can receive remote input to control motor direction and speed. The car shall accept `forward`, `back`, `left`, `right`, and `stop` commands, and execute them reliably (controller event → wheel actuation) | Live demonstration or test log. | EXPECT-L0-4 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/Install%20and%20Test%20Joystick%20in%20AGL.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Remote%20control%201%20evidence_EXPECT_L0_4.mp4<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Remote%20control%202%20evidence_EXPECT_L0_4.mp4 |
| **L0-5** | The system shall be capable of launching a basic Qt application on the PiRacer’s built-in display. | When executed, the program successfully opens a Qt GUI window on the PiRacer’s screen. | Demonstration or screenshot verification. | EXPECT-L0-5 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/first_qt_app.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/tree/main/src/cluster<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/QML-guide.md<br>`docs/demos/first_qt_app.jpeg`<br>`docs/guides/QML-guide.md` |
| **L0-6** | The Qt GUI shall display static graphical elements such as shapes, text, or images to form a simple user interface. | Upon application launch, the display shows visible static content (e.g., rectangle, label, icon). | Visual inspection of the running application. | EXPECT-L0-6 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/mockup1.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/mockup2.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/mockup3.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/mockup4.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/mockup5.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/mockup6.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Cluster-display-sprint3.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Cluster-mockup-sprint3.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Cluster-study.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/QML-guide.md<br>`docs/demos/mockup1.jpeg`<br>`docs/demos/mockup2.jpeg`<br>`docs/demos/mockup3.jpeg`<br>`docs/demos/mockup4.jpeg`<br>`docs/demos/mockup5.jpeg`<br>`docs/demos/mockup6.jpeg`<br>`docs/demos/Cluster-display-sprint3.jpeg`<br>`docs/demos/Cluster-mockup-sprint3.jpeg`<br>`docs/demos/Cluster-study.jpeg`<br>`docs/guides/QML-guide.md` |
| **L0-7** | QT Crosscompilation should be achieved. | We should be able to crosscompile our QT program outside  the Operating System and the included the exec file running on it. | QT program crosscompliation validated with final exec file obtained, and execution of the exec file in the Rasp5 OS. | EXPECT-L0-7 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/system-architecture-cross.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/tree/main/src/cross-compiler<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/tree/fix-qt-app-minor-changes/src/cross-compile<br>`docs/demos/system-architecture-cross.png` |
| **L0-8** | Connect the Rasp5 to the STM 32 (bidirectional) using Can Protocol. | A communication signal should be sent by the Rasp 5 and received in the STM32. This should be observed from Rasp 5 to STM and from STM to Rasp5 (bidirectional communication). | Visual inspection of message passing from RP5 to STM and vice-versa. | EXPECT-L0-8 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/CANbus%20Scheme%20Updated.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/CAN-layout-sprint3.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/CAN-test.gif<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/CAN-overview.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/CAN-test-guide.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/CAN-explanation.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/src/CAN/CAN_test/README.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/images/CANFrame.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/images/CANsignal.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/images/CANtopology.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/images/CANtopology2.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/images/Half-duplex-communication.png<br>`docs/demos/CANbus Scheme Updated.png`<br>`docs/demos/CAN-layout-sprint3.jpeg`<br>`docs/guides/CAN-overview.md`<br>`docs/guides/CAN-test-guide.md`<br>`docs/guides/CAN-explanation.md`<br>`src/CAN/CAN_test/README.md`<br>`docs/images/CANFrame.png`<br>`docs/images/CANsignal.png`<br>`docs/images/CANtopology.png`<br>`docs/images/CANtopology2.png`<br>`docs/images/Half-duplex-communication.png` |
| **L0-9** | ThreadX should be used on the Microcontroller (STM32) as a RTOS, receiving signals from the speedometer and controlling the servos and DC motor. |  We should be able to install and use ThreadX on the Microcontroller (STM32), making all communications (including can) to pass in the STM32 and be controlled/managed there using priorizations and threads. | Software test including Visual inspection of the message bidirectional transmission. | EXPECT-L0-9 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/ThreadX_Installation_Guide.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/AGL%20and%20ThreadX%20benefits%20Guide.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/ThreadX_Running.gif<br>`docs/guides/ThreadX_Installation_Guide.md` |
| **L0-10** | Implement and test the changing from the old architecture to the new architecture (without the expansion board) including power consumption study, new electric scheme, individual module test, and visual test of all the components working. | A system architecture diagram and documents regarding power consumption and new electic scheme are present in the repository. | Documentation inspection. | EXPECT-L0-10 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Validation-of-energy-layout-sprint3.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/eletric-scheme.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Validation-of-energy-layout-sprint1.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Validation-of-energy-layout-sprint2<br>`docs/demos/Validation-of-energy-layout-sprint3.jpeg`<br>`docs/demos/eletric-scheme.png` |
| **L0-11** | The Qt cluster UI shall **auto-start on boot** and display fullscreen on the car’s built-in display. | Upon application launch, the program successfully opens a Qt GUI window on the PiRacer’s screen. | Visual inspection of the running application. | EXPECT-L0-11 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/tree/main/src/cluster<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/images/Flow.jpg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/Cluster-display-sprint4.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/src/stm/Combined_test.md<br>`docs/images/Flow.jpg`<br>`docs/demos/Cluster-display-sprint4.jpeg`<br>`src/stm/Combined_test.md` |
| **L0-12** | The DCI display fullscreen will be out of the car (wireless display) lauching Qt (first without autostart, then with autostart). | Upon application launch, the wireless display should open a Qt GUI window on the PiRacer’s screen with our program. | Visual inspection of the running application. | EXPECT-L0-12 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/tree/main/src/cluster<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/DCI%20display.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/src/stm/Combined_test.md<br>https://github.com/user-attachments/assets/e47dfee6-8d20-4a2b-88ba-0ed2be615f46<br>`src/stm/Combined_test.md` |
| **L0-13** | Project & GitHub setup: The team shall set up a GitHub repository hosting the project code, documentation, and2 version control history. | Repository contains all relevant source code, README, and requirements files. Branches, commits, and pull requests show collaboration among members. | GitHub repository inspection. | EXPECT-L0-13 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/github-guidelines.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/github-actions-guide.md<br>`docs/guides/github-guidelines.md`<br>`docs/guides/github-actions-guide.md` |
| **L0-14** | TSF & Documentation: The project shall apply the Trustable Software Framework (TSF) to define and trace requirements, architecture, and test cases. | TSF documentation exists within the repository, showing traceability. | Documentation review in the GitHub repository. | EXPECT-L0-14 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/TSF/WhatsTSF.md<br>`docs/TSF/tsf_implementation/TSF_docs/WhatsTSF.md` |
| **L0-15** | Agile: The team shall follow Agile (Scrum) methodology for project management. | A Scrum board exists with backlog items, sprint goals, and progress updates. Team conducts dailys, stand-ups, sprint planning and sprint retrospectives. | Review of Scrum board and team reports (dailys and sprints planning and retrospectives). | EXPECT-L0-15 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/tree/main/docs/sprints<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/dailys/dailys_warmups.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/projects?query=is%3Aopen<br>`docs/dailys/dailys_warmups.md` |
| **L0-16** | CI/CD: The project repository shall include a working GitHub Actions workflow for continuous integration (CI) and continuous delivering (CD). | At least one CI workflow successfully builds or tests the project upon commits or pull requests. | Inspection of GitHub Actions run logs. | EXPECT-L0-16 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/github-actions-guide.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/.github/workflows/validate_items_formatation.yml<br>`docs/guides/github-actions-guide.md` |
| **L0-17** | Introduce in the project: AI - GENAI, ML, DL, NEURAL NETWORKS, ETC". | Introduce in the project: AI - GENAI, ML, DL, NEURAL NETWORKS, ETC". | Code implementation verification with achieved effect. | EXPECT-L0-17 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/genAI-pair-programming-guidelines.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/Generative-AI-and-LLMs-for-Dummies.pdf<br>https://github.com/fprezado/generative-ai-for-beginners<br>`docs/guides/genAI-pair-programming-guidelines.md`<br>`docs/guides/Generative-AI-and-LLMs-for-Dummies.pdf` |
| **L0-18** | The vehicle shall communicate via CAN bus also using ThreadX | Threads should create and send messages using CAN Bus to sent/receive messages  successfully | Test logs | EXPECT-L0-18 — Evidence updated automatically<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/CANbus%20Scheme%20Updated.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/CAN-layout-sprint3.jpeg<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/CAN-test.gif<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/demos/ThreadX_Running.gif<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/CAN-overview.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/CAN-test-guide.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/ThreadX_Installation_Guide.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/guides/ThreadXGuide.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/src/CAN/CAN_test/README.md<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/images/CANFrame.png<br>https://github.com/SEAME-pt/SEA-ME_Team6_2025-26/blob/main/docs/images/CANsignal.png<br>`docs/demos/CANbus Scheme Updated.png`<br>`docs/demos/CAN-layout-sprint3.jpeg`<br>`docs/guides/CAN-overview.md`<br>`docs/guides/CAN-test-guide.md`<br>`docs/guides/ThreadX_Installation_Guide.md`<br>`docs/guides/ThreadXGuide.md`<br>`src/CAN/CAN_test/README.md`<br>`docs/images/CANFrame.png`<br>`docs/images/CANsignal.png` |
| **L0-19** | Test requirement for TSF automation | Test the automated generation of TSF items | Manual inspection | EXPECT-L0-19 — No evidence yet |
| **L0-20** | Integrate AI for content generation | Use AI to automatically generate TSF item content | AI-generated content validation | EXPECT-L0-20 — No evidence yet |
| **L0-21** | Test the complete TSF automation workflow | Execute the full automation pipeline from requirement detection to validation | Workflow completion and file generation | EXPECT-L0-21 — No evidence yet |
| **L0-22** | STM32 ThreadX safety-related startup: The STM32-based control system running ThreadX shall initialize and start publishing speed data over CAN within a deterministic and bounded time after power-on. **Justification:** AUTOSAR Classic–like ECUs and RTOS-based MCUs typically achieve startup times in the 10–100 ms range. Tier-1 suppliers (Bosch, Continental) commonly target <100 ms for availability of safety-relevant signals. ThreadX is designed for deterministic startup on MCUs. **References:** AUTOSAR Classic Platform concepts, Azure RTOS ThreadX documentation, Tier-1 automotive RTOS usage (Bosch/Continental). | The STM32 system starts speed data acquisition and CAN transmission within ≤ 100 ms after power-on. | Integration test with timestamp logging at RTOS startup and first CAN frame transmission. External measurement using logic analyzer / oscilloscope / CAN bus analyzer. | EXPECT-L0-22 — No evidence yet |
| **L0-23** | Raspberry Pi 5 AGL boot time: The Raspberry Pi 5–based system running Automotive Grade Linux (AGL) shall complete its operating system initialization and reach a state where middleware services (e.g. KUKSA) are operational within a bounded time after power-on. **Justification:** Linux-based automotive platforms (AGL, QNX, Adaptive AUTOSAR) typically boot in 5–15 s. AGL documentation describes fast boot paths but does not mandate strict limits. This timing does not affect safety, as safety-relevant data is handled by the MCU. **References:** Automotive Grade Linux (AGL) fast boot & critical path boot presentations, Embedded Linux Conference / AGL Summit talks. | The RASP5/AGL system reaches middleware operational state within ≤ 10 s after power-on. | Timestamp logging from bootloader, kernel, systemd, and KUKSA service startup. AGL boot logs analysis. External time measurement (video recording from power-on to service availability). | EXPECT-L0-23 — No evidence yet |
| **L0-24** | Combined startup (ThreadX + AGL): The combined STM32 (ThreadX) and Raspberry Pi 5 (AGL) system shall provide an integrated startup behavior where safety-relevant data is available before or independently of the completion of the AGL boot process. **Justification:** Common automotive architectural practice separates safety-critical MCUs from Linux-based systems. The slower boot domain (AGL) must not block faster safety-relevant functions. **References:** AGL reference architectures, AUTOSAR Adaptive separation of concerns (MCU vs POSIX systems). | Speed data publication from the STM32 is available within ≤ 100 ms after power-on. AGL system becomes operational within ≤ 10 s, without blocking or delaying data publication. No startup conflict occurs between ThreadX and AGL domains. | Integration test. CAN traffic analysis during AGL boot. Correlation of STM32 CAN timestamps with AGL service startup logs. | EXPECT-L0-24 — No evidence yet |
| **L0-25** | Instrument Cluster availability (Qt on Raspberry Pi 4): The instrument cluster system running a Qt-based application on Raspberry Pi 4 shall display an initial usable UI within a bounded time after power-on. **Justification:** OEM instrument cluster guidelines commonly target 1–2 s for first visual feedback after ignition on. AGL and Tier-1 cluster architectures emphasize early visual availability, even with partial data. **References:** OEM instrument cluster UX guidelines (VW Group, Daimler), AGL instrument cluster demo architectures, Qt for automotive HMI best practices. | The initial instrument cluster image is displayed within ≤ 2.0 s after power-on. The Qt application operates independently of backend data availability. Vehicle data values are displayed once published by KUKSA. | Integration test. External time measurement using video recording. Qt application startup logs. Framebuffer / display initialization logs. | EXPECT-L0-25 — No evidence yet |
| **L0-26** | End-to-end system startup time (ThreadX + AGL + Qt): The complete system shall provide end-to-end availability of safety-relevant data and a usable instrument cluster UI within time bounds consistent with common automotive architectural practices. **Justification:** Automotive systems are architected to ensure fast availability of safety-relevant data and early driver feedback, while allowing complex systems to boot in parallel. **References:** AUTOSAR Classic + Adaptive architectural separation, AGL system architecture documentation, Tier-1 automotive cluster and gateway designs. | Safety-relevant speed data is available within ≤ 100 ms after power-on. A usable instrument cluster UI is displayed within ≤ 2.0 s after power-on. Backend services (AGL + KUKSA) become fully operational within ≤ 10 s, without impacting safety or UI availability. | End-to-end integration test. External time measurement (video recording from power-on to UI display). System logs from STM32, AGL, and Qt. CAN traffic correlation with UI updates. | EXPECT-L0-26 — No evidence yet |
| **L0-27** | Emergency braking stopping distance: The emergency braking system shall actuate correctly and stop the vehicle at a safe distance from a detected obstacle. **Justification:** Short-range obstacle detection and emergency braking demonstrators commonly use distances in the 200–500 mm range for low-speed platforms. A minimum remaining distance of 50 mm provides a clear safety margin while remaining realistic for a small-scale vehicle. **References:** Low-speed AEB demonstrators and ADAS lab platforms, Automotive emergency braking concepts. | Given an obstacle detected at 300 mm from the sensor, the vehicle shall stop with a minimum remaining distance of ≥ 50 mm from the obstacle. The braking action shall be triggered automatically once the obstacle detection threshold is reached. | Integration test. Measure the distance between the vehicle and the obstacle after full stop. Video recording of the test execution. | EXPECT-L0-27 — No evidence yet |
| **L0-28** | Exterior temperature measurement accuracy: The system shall measure the exterior temperature with an accuracy suitable for vehicle status display. **Justification:** Automotive exterior temperature sensors typically allow deviations between ±1 °C and ±3 °C, depending on sensor placement and environmental conditions. A tolerance of ±2 °C is realistic and appropriate for a demonstrator system. **References:** Automotive ambient temperature sensing practices, Common NTC / digital temperature sensor specifications. | The measured exterior temperature shall correspond to the reference temperature with a maximum deviation of ±2 °C. | Integration test. Measure the actual exterior temperature using a calibrated thermometer. Compare the reference value with the system-reported temperature. Video or image evidence of the measurement setup. | EXPECT-L0-28 — No evidence yet |
| **L0-29** | Driver presence condition: The vehicle shall only accept driving or autonomous commands when a driver is detected as present inside the vehicle. **Justification:** Driver presence detection is a common prerequisite in automotive systems to prevent unintended operation. In this project, a symbolic driver (the duck) is used to validate the logical gating of vehicle operation. **References:** Automotive driver presence and seat occupancy logic, Functional safety principles: prevention of unintended actuation. | If no driver is detected, the vehicle shall reject all driving or autonomous commands. If a driver is detected (Diogo's duck), the vehicle shall accept driving or autonomous commands. | Integration test. Execute command attempts with and without the driver present. Video recording showing system behavior in both cases. | EXPECT-L0-29 — No evidence yet |
| **L0-30** | Car ready to next module: The vehicle shall be finished to module 2 **Justification:** Architecture finished w/sof and hard ready to next module: AGL, ThreadX, Can, QT, Camera, Sensors, etc **References:** Car ready to ADAS and Machine Learning and OTA module 2 | CAr should be completetly finalized | Visual, Unity, Functional, Integration tests.  | EXPECT-L0-30 — No evidence yet |
| **L0-31** | Unit tests: Ensure all the functions work as exptected by doing unit tests **Justification:** All unit tests must pass to ensure proper functionality **References:** - No external references used | all tests must have passed | Visual, Unity | EXPECT-L0-30 - No evidence yet |
---

## Traceability and Verification

Each Level 0 requirement shall be traceable to:
- **System Architecture Elements** — defining how each requirement is implemented.
- **Level 1 Software Requirements** — specifying the detailed functional behavior.
- **Test Cases** — verifying that each requirement is met and validated.

Traceability will be maintained within the GitHub repository, following the principles of the **Trustable Software Framework (TSF)**.

---

**Document version:** 1.0  
**Last updated:** *October 2025*  
**Author(s):** *PiRacer Warm-Up Team*  
**Repository:** [GitHub Repository Link]
