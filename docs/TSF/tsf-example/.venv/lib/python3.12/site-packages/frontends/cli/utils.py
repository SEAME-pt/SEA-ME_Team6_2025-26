import click
import traceback
import trudag.dotstop.core.exception as exception
import logging
import re
from packaging.version import parse
from pathlib import Path
from trudag.dotstop.core.graph import TrustableGraph
from trudag.dotstop.core.constants import (
    TRUSTABLE_VERSION,
    LAST_FORMAT_VERSION,
)

from typing import Callable, Any


"""
Standalone functions and decorators used by the CLI.
"""

logger = logging.getLogger(__name__)


def describe_item(graph: TrustableGraph, item_name: str, statement: bool) -> str:
    """
    Describes item and formats item details as a human-readable output.

    Args:
        graph: Graph to use for describing the item
        item_name: Item name to be described
        statement: If statement of the item should be included in the output
    """
    reviewed = "reviewed" if graph.get_review_status(item_name) else "unreviewed"
    statement_output = ""
    if statement:
        statement_output = f"\nstatement:\n{graph.get_item(item_name).text}\n"
    parents = "\n".join([parent.name for parent in graph.get_item_parents(item_name)])
    children = "\n".join([child.name for child in graph.get_item_children(item_name)])

    return (
        f"item name: {item_name}\n"
        f"review status: {reviewed}\n"
        f"{statement_output}\n"
        "parents:\n"
        f"{parents}\n\n"
        "children:\n"
        f"{children}"
    )


def abort_click_on(
    *kinds: type[Exception],
) -> Callable[[Callable[..., Any]], Callable[..., Any]]:
    """
    Returns a decorator that catches all exceptions of type `kinds`, logs them, then raises `click.Abort()`.

    Decorator factory function that returns an exception handling decorator for
    use with `click` CLI programs. When an error of type `kinds` is encountered
    it is logged at CRITICAL level. The error is also logged with a full stack
    trace at DEBUG level for later inspection. After logging, a `click.Abort()`
    exception is raised, which `click` will handle to gracefully exit the
    program.

    !!! example
        Consider the simple function `square_root`.

        ```python
        def square_root(arg: float):
            if arg < 0.0
                raise ValueError("Cannot compute square root of negative value.")
            return arg**0.5
        ```

        If this is called with a negative value by a `click` program, we'll get a crash with a stack trace.

        Using the `abort_click_on` decorator

        ```python
        @abort_click_on(ValueError)
        def square_root(arg: float):
            if arg < 0.0
                raise ValueError("Cannot compute square root of negative value.")
            return arg**0.5
        ```

        We instead get a clean exit:

        ```console
        CRITICAL: Cannot compute square root of negative value.
        Aborted!
        ```
    """

    def map_to_clickabort(err: Exception, *args, **kwargs):  # noqa ARG001
        logger.critical(err)
        logger.debug(traceback.format_exc())
        mapped_err = click.Abort()
        mapped_err.__cause__ = err
        return mapped_err

    return exception.map_and_raise(map_to_clickabort, *kinds)


def validate_pick_levels(
    _ctx, _param, value: list[tuple[str, str]]
) -> list[tuple[str, int | None, int | None]]:
    new_value = []
    for arg in value:
        picked, levels = arg
        if ":" not in levels:
            raise click.BadParameter(
                "format of levels should be `parent_levels:children_levels`, either can be unspecified but the `:` separator is required"
            )

        parent_levels_raw, _, child_levels_raw = levels.partition(":")

        parent_levels_raw = parent_levels_raw.strip()
        parent_levels = None
        if parent_levels_raw:
            if not parent_levels_raw.isdigit():
                raise click.BadParameter(
                    "format of levels should be `parent_levels:children_levels` where they are both integer values or unspecified"
                )
            parent_levels = int(parent_levels_raw)

        child_levels_raw = child_levels_raw.strip()
        child_levels = None
        if child_levels_raw:
            if not child_levels_raw.isdigit():
                raise click.BadParameter(
                    "format of levels should be `parent_levels:children_levels` where they are both integer values or unspecified"
                )
            child_levels = int(child_levels_raw)

        new_value.append((picked, parent_levels, child_levels))

    return new_value


def parse_ranks(rank_list_str: list[str]) -> list[list[str]]:
    """
    Parse the 'list as string' of a rank tuple into a Python list.
    """
    rank_list = []
    for item_list_str in rank_list_str:
        item_list = [item.strip() for item in item_list_str.split(",")]
        rank_list.append(item_list)
    return rank_list


def validate_trudag_version(graph_source: Path) -> None:
    """
    Compare the trudag version with the version used to generate the dotfile.

    Raises:
        VersionError: If the trudag version and the version used to
        generate the dotfile have different dotfile formatting.
    """
    dotfile_version = ""
    with graph_source.open("r") as f:
        f.readline()
        second_line = f.readline()
        if match := re.search(r"(\d+\.\d+\.\d+)", second_line):
            dotfile_version = match.group(1)
        else:
            raise exception.VersionError("dotfile version not specified")

    if (
        dotfile_version != TRUSTABLE_VERSION
        and parse(dotfile_version) < LAST_FORMAT_VERSION
    ):
        err_msg = (
            "trudag version mismatch:\n"
            f"  current trudag version: {TRUSTABLE_VERSION}\n"
            f"  version used to generate the dotfile: {dotfile_version}\n"
            "changes have been made to formatting of the dotfile between these versions.\n"
            "run `trudag manage format` to reformat the dotfile and resolve git conflicts "
            "before making changes to the dotfile."
        )
        raise exception.VersionError(err_msg)
