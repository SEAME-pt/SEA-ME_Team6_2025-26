# ******************************************************************************
# * Copyright (c) 2024-5 Codethink
# *
# * This program and the accompanying materials are made available under the
# * terms of the Eclipse Public License 2.0 which is available at
# * http://www.eclipse.org/legal/epl-2.0.
# *
# * This Source Code may also be made available under the following Secondary
# * Licenses when the conditions for such availability set forth in the Eclipse
# * Public License, v. 2.0 are satisfied: GNU General Public License, version 2
# * with the GNU Classpath Exception which is
# * available at https://www.gnu.org/software/classpath/license.html.
# *
# * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
# ******************************************************************************

import json
import hashlib
import logging

import trudag.utils as utils
from pathlib import Path
from datetime import datetime
from schema import Schema, And, Optional

from trudag.dotstop.core.item import MarkdownItem
from trudag.dotstop.core.graph import build_trustable_graph, TrustableGraph
from trudag.dotstop.core.constants import DataObject
from trudag.dotstop.core.exception import ArtifactError
from trudag.score import score

logger = logging.getLogger(__name__)

ARTIFACT_SCHEMA = Schema(
    {
        "resolved": {
            "dot_graph": And(str, len),
            "items": [
                {
                    "name": And(str, len),
                    "text": str,
                    # Set true if doesn't exist.
                    Optional("normative"): bool,
                    Optional("references"): [
                        {
                            "type": str,
                            "origin": str,
                            "text_content": str,
                            "sha": And(str, len),
                        }
                    ],
                    "sha": And(str, len),
                }
            ],
            "scores": {And(str, len): float},
            "sha": And(str, len),
        },
        Optional("needs"): {
            "dot_graph": And(str, len),
            "items": [
                {
                    "name": And(str, len),
                    "text": str,
                    Optional("normative"): bool,
                    Optional("references"): [DataObject],
                }
            ],
        },
        "metadata": {
            "Project Name": str,
            "Commit SHA": str,
            "Commit date/time": str,
            "Commit tag": str,
        },
    },
    ignore_extra_keys=True,
)


class Artifact:
    """
    Provides a class to interact with artifact files. This could used to export and import artifacts.
    This class also supports the context manager protocol to be able to rollback any changes during importing from artifact files
    in the case of failure.
    """

    needs_graph: TrustableGraph
    resolved_graph: TrustableGraph
    _local_graph: TrustableGraph
    _local_dot: Path
    _backup_dot: str

    def __init__(self):
        self.metadata = {}
        self._imported_items = []
        self._artifact = {}

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if self._imported_items:
            if type:
                # we have an error we remove all the extra created files and revert the local dotfile changes
                for imported_file in self._imported_items:
                    if imported_file.exists():
                        imported_file.unlink(missing_ok=True)
                if not any(self._imported_items[0].parent.iterdir()):
                    self._imported_items[0].parent.rmdir()
                self._local_dot.write_text(self._backup_dot)
                return False

            self._local_graph.to_file(self._local_dot)
        else:
            if type:
                raise type(value)
        return True

    def export_to(self, graph: TrustableGraph, project_name: str, file: Path):
        """
        Exports an artifact including the `graph` and needs to the given `file` named with `project_name`.
        Args:
            graph(TrustableGraph): The graph to export through an artifact.
            project_name(str): The name stored for the project in the artifact metadata.
            file(Path): Output path for the artifact file.
        """
        self._local_graph = graph
        workdir = utils.get_workdir()
        needs_file = Path(workdir / utils.NEEDS_DEFAULT_FILENAME)
        if needs_file.is_file():
            needs_graph = build_trustable_graph(
                graph_source=needs_file,
                items_source=workdir,
            )
        else:
            logger.warning(".needs.dot does not exist, artifact will have no needs")
            needs_graph = None
        self._write_resolved_graph_artifact(needs_graph, file, project_name)

    def import_from(
        self,
        file: Path,
        graph: TrustableGraph,
        local_dot: Path,
        namespace: str,
        needs_dir: Path,
        graph_root: str,
    ):
        """
        Imports needs items and a resolved remote graph, to be prefixed with a `namespace`, from an artifact `file` into a `needs_dir` directory.
        Args:
            file(Path): Input path for the artifact file.
            graph(TrustableGraph): The local graph to be updated.
            local_dot(Path): The path of the local dotstop file to be updated.
            namespace(str): The namespace name to be prepended for the imported items.
            needs_dir(Path): The path of the output directory for the needs files to be stored.
            graph_root(str): The name of the scored root item in the resolved graph to be imported and added to the local graph.
        """
        self._artifact = json.loads(file.read_text())
        ARTIFACT_SCHEMA.validate(self._artifact)

        self._local_graph = graph
        self._backup_dot = local_dot.read_text()
        self.resolved_graph = self._build_imported_graph(self._artifact["resolved"])
        self._imported_items = [Path(f"{needs_dir}/{namespace}.{graph_root}.md")]
        self._local_dot = local_dot
        self.metadata = self._artifact["metadata"]

        if needs := self._artifact.get("needs"):
            self.needs_graph = self._build_imported_graph(needs)
            needs_dir.mkdir(parents=True, exist_ok=True)
            for need in self.needs_graph.items:
                needs_file = Path(f"{needs_dir}/{namespace}.{need}.md")
                self._imported_items.append(needs_file)
                needs_file.write_text(need.as_markdown())

            self.needs_graph.add_namespace(namespace)
            self._local_graph.add_items(self.needs_graph.items)

        self._make_root_item(needs_dir, namespace, graph_root)

    def _write_resolved_graph_artifact(
        self,
        needs_graph: TrustableGraph | None,
        file: Path,
        project_name: str,
    ):
        artifact = {}
        score_map = score(self._local_graph, True)
        sha = hashlib.sha256()
        sha.update(str(self._local_graph).encode())
        for item in self._local_graph.items:
            sha.update(item.sha.encode())
        sha.update(json.dumps(score_map).encode())
        artifact["resolved"] = {
            "dot_graph": str(self._local_graph),
            "items": [item.as_data for item in self._local_graph.items],
            "scores": score_map,
            "sha": sha.hexdigest(),
        }

        if needs_graph:
            needs_graph.stamp_needs()
            artifact["needs"] = {
                "dot_graph": str(needs_graph),
                "items": [item.as_needs for item in needs_graph.items],
            }
        artifact["metadata"] = {
            "Project Name": project_name,
            "Commit SHA": utils.get_commit_sha() or "None",
            "Commit date/time": str(
                datetime.fromtimestamp(utils.get_commit_timestamp() or 0)
            ),
            "Commit tag": utils.get_last_tag() or "None",
        }
        ARTIFACT_SCHEMA.validate(artifact)
        with file.open("w") as f:
            json.dump(artifact, f)

    def _build_imported_graph(self, read_graph: dict):
        return build_trustable_graph(
            graph_source=read_graph["dot_graph"],
            items_source=[
                MarkdownItem.from_data(item_data) for item_data in read_graph["items"]
            ],
        )

    def _make_root_item(self, needs_dir: Path, namespace: str, root_node: str):
        if not any(item.name == root_node for item in self.resolved_graph.items):
            msg = f"The root name {root_node} requested is not present in the artifact!"
            raise ArtifactError(msg)
        self.resolved_graph.add_namespace(namespace)
        namespaced_name = f"{namespace}.{root_node}"
        text = ""
        scores = self._artifact["resolved"]["scores"]
        with (needs_dir / Path(f"{namespaced_name}.md")).open("w") as root_file:
            root_scores = "score:\n"
            metadata = ""
            if root_score := scores.get(root_node):
                root_scores += f"    {root_node}: {root_score}\n"
            for metadata_k, metadata_v in self.metadata.items():
                metadata += f"* {metadata_k}: {metadata_v}\n\n"
            text = (
                "---\nnormative: true\n"
                + f"references:\n    - type: file\n      path: {root_file.name}\n"
                + root_scores
                + "---\n\n"
                + metadata
            )

            root_file.writelines(text)
        root_item = MarkdownItem.from_markdown(namespaced_name, text)
        self._local_graph.add_items([root_item])
        self._local_graph.set_review_status(root_item.name, True)
