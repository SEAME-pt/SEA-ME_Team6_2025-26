import logging
import json
import os
import re
from git import InvalidGitRepositoryError, Repo
from pathlib import Path
from colorama import Fore, Style

from trudag.dotstop.core.data_store.data_model import validate_data
from trudag.dotstop.core.data_store.data_store_client import DATA_STORE_CLIENT_SINGLETON
from trudag.dotstop.core.data_store.version import SCHEMA_VERSION
from trudag.dotstop.core.exception import PluginError, GraphStructureError
from trudag.dotstop.core.constants import (
    FILE_MARKER,
)

"""
Standalone functions and decorators used by the library.
"""

logger = logging.getLogger(__name__)


NEEDS_DEFAULT_FILENAME = Path(".needs.dot")
DOTSTOP_DEFAULT_FILENAME = Path(".dotstop.dot")
OUTPUT_SEPARATOR = f"{Fore.BLUE}{('-' * 100)}{Style.RESET_ALL}"
"""
Filename in the root directory assumed to contain a dot graph generated by trudag.
"""


def dump_scores(scores: dict[str, float], dump: Path) -> None:
    """
    Outputs the provided Trustable `scores` to a provided `dump` path as one of the supported files.
    """
    if dump:
        ext: str = dump.suffix
        if ext == ".json" or str(dump) == "data_store":
            scores_data = json.loads('{"scores":[]}')
            for key, value in scores.items():
                scores_data["scores"].append({"id": key, "score": value})

            scores_data["info"] = {}
            scores_data["info"]["Repository root"] = get_root_dir()
            scores_data["info"]["Commit SHA"] = get_commit_sha()
            scores_data["info"]["Commit date/time"] = get_commit_timestamp()
            scores_data["info"]["Commit tag"] = get_last_tag()
            scores_data["info"]["CI job id"] = get_ci_job_id()
            scores_data["info"]["Branch name"] = get_branch_name()
            scores_data["info"]["Schema version"] = SCHEMA_VERSION

            validate_data([scores_data])

            if ext == ".json":
                with dump.open("w") as file:
                    json.dump(scores_data, file, ensure_ascii=False)
            else:
                dsc = DATA_STORE_CLIENT_SINGLETON.get()
                try:
                    dsc.push([scores_data])
                except Exception as e:
                    raise PluginError(f"Error in data store connector {e}") from e

        elif ext == ".csv":
            csv_rows: list[str] = []
            for key, value in sorted(scores.items()):
                csv_rows.append(f"{key},{value}\n")

            csv_rows.append(f"Repository root,{get_root_dir()}\n")
            csv_rows.append(f"Commit SHA,{get_commit_sha()}\n")
            csv_rows.append(f"Commit date/time,{get_commit_timestamp()}\n")
            csv_rows.append(f"Commit tag,{get_last_tag()}\n")

            with dump.open("w") as file:
                file.writelines(csv_rows)
        else:
            logger.error(
                f"Cannot dump scores, file extension '{ext}' is not supported."
            )


def get_workdir() -> Path:
    """
    Get the cli working directory.

    If the current working directory is a git repo, return the top level
    directory of the repo. If not, return the current working directory.
    """
    repo = None
    try:
        repo = get_repo()
    except InvalidGitRepositoryError:
        return Path.cwd()

    return Path(repo.git.rev_parse(show_toplevel=True))


def make_dotfile(filepath: Path, graph_name: str) -> None:
    """
    Make a dotfile representing an empty database at `path` and using a `graph_name`.
    """
    # dot file ID names can't begin with digits
    if re.match(r"^\d.*", graph_name) or not graph_name:
        err_msg = f"Invalid graph name: {graph_name}."
        raise GraphStructureError(err_msg)

    if filepath.exists():
        err_msg = f"Cannot overwrite file {filepath} to create new empty dot database."
        raise FileExistsError(err_msg)
    filepath.write_text(f"{FILE_MARKER} digraph {graph_name} {{\n}}")
    logger.info(f"Created new dot database at {filepath}")


def get_root_dir() -> str:
    """
    Returns the top level directory of the git repository. If no git repository is found
    returns the current working directory.
    """
    try:
        return get_repo().git.rev_parse(show_toplevel=True)
    except InvalidGitRepositoryError:
        logger.warning(
            "Couldn't get a git repository root, using the current working directory."
        )
    return str(Path.cwd())


def get_commit_sha() -> str | None:
    """
    The git commit sha for HEAD, if it exists.
    """
    try:
        repo = get_repo()
        return repo.git.rev_parse(repo.head)
    except InvalidGitRepositoryError:
        logger.warning("Couldn't get a git commit in the directory.")
    return None


def get_last_tag() -> str | None:
    """
    The most recent git tag (either annotated or lightweight) for HEAD, if it exists.

    Returned string has format
    `<latest tag>-<# commits since last tag>-<short SHA>` if the current
    commit is not tagged. If the commit is tagged, return `<latest tag>`
    """
    try:
        return get_repo().git.describe(tags=True, long=True, always=True, abbrev=7)
    except InvalidGitRepositoryError:
        logger.warning("Couldn't get a git tag in the directory.")
    return None


def get_commit_timestamp() -> int | None:
    """
    The UNIX timestamp in seconds for commit at HEAD.
    """
    try:
        return int(get_repo().head.commit.committed_datetime.timestamp())
    except InvalidGitRepositoryError:
        logger.warning("Couldn't get a git commit date in the directory.")
    return None


def get_branch_name() -> str | None:
    """
    The branch name
    """
    try:
        return get_repo().head.ref.name
    except InvalidGitRepositoryError:
        logger.warning("Couldn't get a git branch name in the directory.")
    except TypeError as e:
        logger.warning(e)
    return None


def get_ci_job_id() -> str:
    """
    The CI job id
    """
    out = os.environ.get("GITHUB_RUN_ATTEMPT")
    if out is None:
        out = os.environ.get("CI_JOB_ID", None)
    return out


def get_repo() -> Repo:
    return Repo(search_parent_directories=True)
