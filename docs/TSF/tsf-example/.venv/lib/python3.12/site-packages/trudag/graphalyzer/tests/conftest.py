# ******************************************************************************
# * Copyright (c) 2024-5 Codethink
# *
# * This program and the accompanying materials are made available under the
# * terms of the Eclipse Public License 2.0 which is available at
# * http://www.eclipse.org/legal/epl-2.0.
# *
# * This Source Code may also be made available under the following Secondary
# * Licenses when the conditions for such availability set forth in the Eclipse
# * Public License, v. 2.0 are satisfied: GNU General Public License, version 2
# * with the GNU Classpath Exception which is
# * available at https://www.gnu.org/software/classpath/license.html.
# *
# * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
# ******************************************************************************

import pytest
import numpy as np
import trudag.graphalyzer.graph as gzrgraph


@pytest.fixture(scope="module")
def unweighted():
    r"""
    Six node unweighted DAG fixture with hand-calculated properties. Edges are
    all directed downwards.

          A
         / \
        B   C
        |\  |
        | D |
        |/ \|
        E   F
    """
    return {
        # Graph Definition
        "dag": gzrgraph.DirectedAcyclicGraph(
            np.array(
                [
                    [0, 1, 1, 0, 0, 0],
                    [0, 0, 0, 1, 1, 0],
                    [0, 0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 1, 1],
                    [0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0],
                ]
            )
        ),
        # Algebraic Properties
        "size": 6,
        "adjacency": np.array(
            [
                [0, 1, 1, 0, 0, 0],
                [0, 0, 0, 1, 1, 0],
                [0, 0, 0, 0, 0, 1],
                [0, 0, 0, 0, 1, 1],
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0],
            ]
        ),
        "symmetric_adjacency": np.array(
            [
                [0, 1, 1, 0, 0, 0],
                [1, 0, 0, 1, 1, 0],
                [1, 0, 0, 0, 0, 1],
                [0, 1, 0, 0, 1, 1],
                [0, 1, 0, 1, 0, 0],
                [0, 0, 1, 1, 0, 0],
            ]
        ),
        "indegree": np.array(
            [
                [0, 0, 0, 0, 0, 0],
                [0, 1, 0, 0, 0, 0],
                [0, 0, 1, 0, 0, 0],
                [0, 0, 0, 1, 0, 0],
                [0, 0, 0, 0, 2, 0],
                [0, 0, 0, 0, 0, 2],
            ]
        ),
        "outdegree": np.array(
            [
                [2, 0, 0, 0, 0, 0],
                [0, 2, 0, 0, 0, 0],
                [0, 0, 1, 0, 0, 0],
                [0, 0, 0, 2, 0, 0],
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0],
            ]
        ),
        "degree": np.array(
            [
                [2, 0, 0, 0, 0, 0],
                [0, 3, 0, 0, 0, 0],
                [0, 0, 2, 0, 0, 0],
                [0, 0, 0, 3, 0, 0],
                [0, 0, 0, 0, 2, 0],
                [0, 0, 0, 0, 0, 2],
            ]
        ),
        "laplacian": np.array(
            [
                [2, -1, -1, 0, 0, 0],
                [-1, 3, 0, -1, -1, 0],
                [-1, 0, 2, 0, 0, -1],
                [0, -1, 0, 3, -1, -1],
                [0, -1, 0, -1, 2, 0],
                [0, 0, -1, -1, 0, 2],
            ]
        ),
        "normalized_adjacency": np.array(
            [
                [0.0, 0.5, 0.5, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.5, 0.5, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.5, 0.5],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            ]
        ),
        "unweighted_adjacency": np.array(
            [
                [0.0, 1.0, 1.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 1.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            ]
        ),
        "reversed_adjacency": np.array(
            [
                [0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0],
                [0, 1, 0, 0, 0, 0],
                [0, 1, 0, 1, 0, 0],
                [0, 0, 1, 1, 0, 0],
            ]
        ),
        "connected": True,
        "leaves": (["E", "F"], [4, 5]),
        "roots": (["A"], [0]),
        "nodes": (["A", "B", "C", "D", "E", "F"], [0, 1, 2, 3, 4, 5]),
        "is_normalized": False,
        "is_unweighted": True,
        # Analysis Results
        "leaf_scores_dict": {"E": 0.1, "F": 0.2},
        "completeness_scores_dict": None,
        "all_scores_dict": {"A": 0.6, "B": 0.4, "C": 0.2, "D": 0.3, "E": 0.1, "F": 0.2},
        "node_label_for_sensitivities": "A",
        "node_sensitivities_dict": {
            "A": 1.0,
            "B": 1.0,
            "C": 1.0,
            "D": 1.0,
            "E": 2.0,
            "F": 2.0,
        },
        "edge_labels_for_sensitivities": ("B", "D"),
        "edge_sensitivities_dict": {
            "A": 0.3,
            "B": 0.3,
            "C": 0.0,
            "D": 0.0,
            "E": 0.0,
            "F": 0.0,
        },
    }


@pytest.fixture(scope="module")
def weighted():
    r"""
    Larger and more complex weighted DAG fixture with multiple roots and leaves,
    with hand calculated properties. Edges are all directed downwards. Weights
    are recorded in the constructor adjacency matrix. Two nodes are
    intentionally out of alphabetical sequence to ensure a non-upper-diagonal
    adjacency matrix.

        A    B
        |\  /|\
        | \/ | \
        | /\ |  \
        |/  \|   \
        C    I    E
         \  /|   /|
          \/ |  / |
          /\ | /  |
         /  \|/   |
        |    F    G
         \  /    /|
          \/    / |
          /\   /  |
         /  \ /   |
        H    D    J
    """
    return {
        # Graph Definition
        "dag": gzrgraph.DirectedAcyclicGraph(
            np.array(
                [
                    # A    B    C    D    E    F    G    H    I    J
                    [0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0],  # A
                    [0.0, 0.0, 0.7, 0.0, 0.2, 0.0, 0.0, 0.0, 0.1, 0.0],  # B
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0],  # C
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.6, 0.0, 0.0, 0.0],  # E
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0, 0.0],  # F
                    [0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4],  # G
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                    [0.0, 0.0, 0.0, 0.1, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0],  # I
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # J
                ]
            )
        ),
        # Algebraic Properties
        "size": 10,
        "adjacency": np.array(
            [
                # A    B    C    D    E    F    G    H    I    J
                [0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0],  # A
                [0.0, 0.0, 0.7, 0.0, 0.2, 0.0, 0.0, 0.0, 0.1, 0.0],  # B
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.6, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0, 0.0],  # F
                [0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                [0.0, 0.0, 0.0, 0.1, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0],  # I
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # J
            ]
        ),
        "symmetric_adjacency": np.array(
            [
                # A    B    C    D    E    F    G    H    I    J
                [0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0],  # A
                [0.0, 0.0, 0.7, 0.0, 0.2, 0.0, 0.0, 0.0, 0.1, 0.0],  # B
                [0.1, 0.7, 0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.1, 0.0],  # D
                [0.0, 0.2, 0.0, 0.0, 0.0, 0.4, 0.6, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.2, 0.0, 0.4, 0.0, 0.0, 0.3, 0.3, 0.0],  # F
                [0.0, 0.0, 0.0, 0.2, 0.6, 0.0, 0.0, 0.0, 0.0, 0.4],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0],  # H
                [0.6, 0.1, 0.0, 0.1, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0],  # I
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.0, 0.0, 0.0],  # J
            ]
        ),
        "indegree": np.array(
            [
                # A    B    C    D    E    F    G    H    I    J
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.0, 0.0, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.9, 0.0, 0.0, 0.0, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7, 0.0],  # I
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4],  # J
            ]
        ),
        "outdegree": np.array(
            [
                # A    B    C    D    E    F    G    H    I    J
                [0.7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.0],  # I
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # J
            ]
        ),
        "degree": np.array(
            [
                # A    B    C    D    E    F    G    H    I    J
                [0.7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.0, 1.2, 0.0, 0.0, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.0, 0.0, 0.0, 1.2, 0.0, 0.0, 0.0, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.2, 0.0, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.1, 0.0],  # I
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4],  # J
            ]
        ),
        "laplacian": np.array(
            [
                # A    B    C    D    E    F    G    H    I    J
                [0.7, 0.0, -0.1, 0.0, 0.0, 0.0, 0.0, 0.0, -0.6, 0.0],  # A
                [0.0, 1.0, -0.7, 0.0, -0.2, 0.0, 0.0, 0.0, -0.1, 0.0],  # B
                [-0.1, -0.7, 1.0, 0.0, 0.0, -0.2, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.3, 0.0, 0.0, -0.2, 0.0, -0.1, 0.0],  # D
                [0.0, -0.2, 0.0, 0.0, 1.2, -0.4, -0.6, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, -0.2, 0.0, -0.4, 1.2, 0.0, -0.3, -0.3, 0.0],  # F
                [0.0, 0.0, 0.0, -0.2, -0.6, 0.0, 1.2, 0.0, 0.0, -0.4],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, -0.3, 0.0, 0.3, 0.0, 0.0],  # H
                [-0.6, -0.1, 0.0, -0.1, 0.0, -0.3, 0.0, 0.0, 1.1, 0.0],  # I
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.4, 0.0, 0.0, 0.4],  # J
            ]
        ),
        "normalized_adjacency": np.array(
            [
                [
                    # A    B    C    D    E    F    G    H    I    J
                    [0.0, 0.0, 1.0 / 7.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.0 / 7.0, 0.0],  # A
                    [0.0, 0.0, 0.7, 0.0, 0.2, 0.0, 0.0, 0.0, 0.1, 0.0],  # B
                    [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0],  # C
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.6, 0.0, 0.0, 0.0],  # E
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],  # F
                    [0.0, 0.0, 0.0, 1.0 / 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0 / 3.0],  # G
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                    [0.0, 0.0, 0.0, 0.25, 0.0, 0.75, 0.0, 0.0, 0.0, 0.0],  # I
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # J
                ]
            ]
        ),
        "unweighted_adjacency": np.array(
            [
                [
                    # A    B    C    D    E    F    G    H    I    J
                    [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0],  # A
                    [0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0],  # B
                    [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0],  # C
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                    [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0],  # E
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],  # F
                    [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],  # G
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                    [0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0],  # I
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # J
                ]
            ]
        ),
        "reversed_adjacency": np.array(
            [
                # A    B    C    D    E    F    G    H    I    J
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.1, 0.7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.1, 0.0],  # D
                [0.0, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.2, 0.0, 0.4, 0.0, 0.0, 0.0, 0.3, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0],  # H
                [0.6, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.0, 0.0, 0.0],  # J
            ]
        ),
        "connected": True,
        "leaves": (["D", "H", "J"], [3, 7, 9]),
        "roots": (["A", "B"], [0, 1]),
        "nodes": (
            ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"],
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        ),
        "is_normalized": False,
        "is_unweighted": False,
        # Analysis Results
        "leaf_scores_dict": {"H": 0.1, "D": 0.5, "J": 0.2},
        "completeness_scores_dict": None,
        "all_scores_dict": {
            "A": 0.036,
            "B": 0.0341,
            "C": 0.006,
            "D": 0.5,
            "E": 0.12,
            "F": 0.03,
            "G": 0.18,
            "H": 0.1,
            "I": 0.059,
            "J": 0.2,
        },
        "node_label_for_sensitivities": "I",
        "node_sensitivities_dict": {
            "A": 0.0,
            "B": 0.0,
            "C": 0.0,
            "D": 0.1,
            "E": 0.0,
            "F": 0.3,
            "G": 0.0,
            "H": 0.09,
            "I": 1.0,
            "J": 0.0,
        },
        "edge_labels_for_sensitivities": ("F", "H"),
        "edge_sensitivities_dict": {
            "A": 0.02,
            "B": 0.025,
            "C": 0.02,
            "D": 0.0,
            "E": 0.04,
            "F": 0.1,
            "G": 0.0,
            "H": 0.0,
            "I": 0.03,
            "J": 0.0,
        },
    }


@pytest.fixture(scope="module")
def unconnected():
    r"""
    Unconnected DAG with multiple roots and leaves, with hand calculated properties
    Edges are all directed downwards
    Weights are recorded in the constructor adjacency matrix

           A           D     I
          / \         / \
         /   \       /   \
        B     C     E     F
                   / \   /
                  /   \ /
                 G     H
    """
    return {
        # Graph Definition
        "dag": gzrgraph.DirectedAcyclicGraph(
            np.array(
                [
                    # A    B    C    D    E    F    G    H    I
                    [0.0, 0.2, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                    [0.0, 0.0, 0.0, 0.0, 0.6, 0.2, 0.0, 0.0, 0.0],  # D
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.3, 0.0],  # E
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0],  # F
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # G
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
                ]
            )
        ),
        # Algebraic Properties
        "size": 9,
        "adjacency": np.array(
            [
                # A    B    C    D    E    F    G    H    I
                [0.0, 0.2, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.0, 0.6, 0.2, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.3, 0.0],  # E
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
            ]
        ),
        "symmetric_adjacency": np.array(
            [
                # A    B    C    D    E    F    G    H    I
                [0.0, 0.2, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.0, 0.6, 0.2, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.2, 0.3, 0.0],  # E
                [0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.1, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.3, 0.1, 0.0, 0.0, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
            ]
        ),
        "indegree": np.array(
            [
                # A    B    C    D    E    F    G    H    I
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.0, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.0, 0.0, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
            ]
        ),
        "outdegree": np.array(
            [
                # A    B    C    D    E    F    G    H    I
                [0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
            ]
        ),
        "degree": np.array(
            [
                # A    B    C    D    E    F    G    H    I
                [0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.0, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.0, 0.0, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.0, 1.1, 0.0, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.3, 0.0, 0.0, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
            ]
        ),
        "laplacian": np.array(
            [
                # A    B    C    D    E    F    G    H    I
                [0.6, -0.2, -0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [-0.2, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [-0.4, 0.0, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.8, -0.6, -0.2, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, -0.6, 1.1, 0.0, -0.2, -0.3, 0.0],  # E
                [0.0, 0.0, 0.0, -0.2, 0.0, 0.3, 0.0, -0.1, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, -0.2, 0.0, 0.2, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, -0.3, -0.1, 0.0, 0.4, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
            ]
        ),
        "normalized_adjacency": np.array(
            [
                [
                    # A    B    C    D    E    F    G    H    I
                    [0.0, 1.0 / 3.0, 2.0 / 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                    [0.0, 0.0, 0.0, 0.0, 0.75, 0.25, 0.0, 0.0, 0.0],  # D
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.6, 0.0],  # E
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0],  # F
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # G
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
                ]
            ]
        ),
        "unweighted_adjacency": np.array(
            [
                [
                    # A    B    C    D    E    F    G    H    I
                    [0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                    [0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0],  # D
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0],  # E
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0],  # F
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # G
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # H
                    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
                ]
            ]
        ),
        "reversed_adjacency": np.array(
            [
                # A    B    C    D    E    F    G    H    I
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # A
                [0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # B
                [0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # C
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # D
                [0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0],  # E
                [0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0],  # F
                [0.0, 0.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0],  # G
                [0.0, 0.0, 0.0, 0.0, 0.3, 0.1, 0.0, 0.0, 0.0],  # H
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # I
            ]
        ),
        "connected": False,
        "leaves": (["B", "C", "G", "H", "I"], [1, 2, 6, 7, 8]),
        "roots": (["A", "D", "I"], [0, 3, 8]),
        "nodes": (
            ["A", "B", "C", "D", "E", "F", "G", "H", "I"],
            [0, 1, 2, 3, 4, 5, 6, 7, 8],
        ),
        "is_normalized": False,
        "is_unweighted": False,
        # Analysis Results
        "leaf_scores_dict": {"B": 0.2, "C": 0.5, "G": 0.1, "H": 0.6, "I": 0.7},
        "completeness_scores_dict": None,
        "all_scores_dict": {
            "A": 0.24,
            "B": 0.2,
            "C": 0.5,
            "D": 0.132,
            "E": 0.2,
            "F": 0.06,
            "G": 0.1,
            "H": 0.6,
            "I": 0.7,
        },
        "node_label_for_sensitivities": "D",
        "node_sensitivities_dict": {
            "A": 0.0,
            "B": 0.0,
            "C": 0.0,
            "D": 1.0,
            "E": 0.6,
            "F": 0.2,
            "G": 0.12,
            "H": 0.2,
            "I": 0.0,
        },
        "edge_labels_for_sensitivities": ("E", "H"),
        "edge_sensitivities_dict": {
            "A": 0.0,
            "B": 0.0,
            "C": 0.0,
            "D": 0.36,
            "E": 0.6,
            "F": 0.0,
            "G": 0.0,
            "H": 0.0,
            "I": 0.0,
        },
    }


@pytest.fixture(scope="module")
def unweighted_incomplete(unweighted):
    r"""
          A   (A completeness: 0.8)
         / \
        B   C (B completeness: 0.2)
        |\  |
        | D | (D completeness: 0.5)
        |/ \|
        E   F
    """
    graph = unweighted
    graph["completeness_scores_dict"] = {
        "A": 0.8,
        "B": 0.2,
        "C": 1.0,
        "D": 0.5,
        "E": 1.0,
        "F": 1.0,
    }
    graph["all_scores_dict"] = {
        "A": 0.2,
        "B": 0.05,
        "C": 0.2,
        "D": 0.15,
        "E": 0.1,
        "F": 0.2,
    }
    return graph


@pytest.fixture(scope="module")
def weighted_incomplete(weighted):
    r"""
        A    B       (A completeness: 0.9)
        |\  /|\
        | \/ | \
        | /\ |  \
        |/  \|   \
        C    I    E  (I completeness: 0.2)
         \  /|   /|  (C completeness: 0.5)
          \/ |  / |
          /\ | /  |
         /  \|/   |
        |    F    G  (G completeness: 0.25)
         \  /    /|
          \/    / |
          /\   /  |
         /  \ /   |
        H    D    J
    """
    graph = weighted
    graph["completeness_scores_dict"] = {
        "A": 0.9,
        "B": 1.0,
        "C": 0.5,
        "D": 1.0,
        "E": 1.0,
        "F": 1.0,
        "G": 0.25,
        "H": 1.0,
        "I": 0.2,
        "J": 1.0,
    }
    graph["all_scores_dict"] = {
        "A": 0.006642,
        "B": 0.01108,
        "C": 0.003,
        "D": 0.5,
        "E": 0.039,
        "F": 0.03,
        "G": 0.045,
        "H": 0.1,
        "I": 0.0118,
        "J": 0.2,
    }
    return graph


@pytest.fixture(scope="module")
def unconnected_incomplete(unconnected):
    r"""

           A           D     I  (A completeness: 0.5) 
          / \         / \       (I completeness: 0.45)
         /   \       /   \
        B     C     E     F     (E completeness: 0.0)
                   / \   /
                  /   \ /
                 G     H        (H completeness: 0.8)
    """
    graph = unconnected
    graph["completeness_scores_dict"] = {
        "A": 0.5,
        "B": 1.0,
        "C": 1.0,
        "D": 1.0,
        "E": 0.0,
        "F": 1.0,
        "G": 1.0,
        "H": 0.8,
        "I": 0.45,
    }
    graph["all_scores_dict"] = {
        "A": 0.12,
        "B": 0.2,
        "C": 0.5,
        "D": 0.0096,
        "E": 0.0,
        "F": 0.048,
        "G": 0.1,
        "H": 0.48,
        "I": 0.315,
    }
    return graph
